<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>指令系统 | font 文件格式文档</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.f3e2e2a4.css" as="style"><link rel="preload" href="/assets/js/app.ab2bc41e.js" as="script"><link rel="preload" href="/assets/js/2.f8441915.js" as="script"><link rel="preload" href="/assets/js/1.582e94f5.js" as="script"><link rel="preload" href="/assets/js/13.61a706c7.js" as="script"><link rel="prefetch" href="/assets/js/10.b393b446.js"><link rel="prefetch" href="/assets/js/11.164e568a.js"><link rel="prefetch" href="/assets/js/12.e548e10e.js"><link rel="prefetch" href="/assets/js/14.d1e48fa8.js"><link rel="prefetch" href="/assets/js/15.88a68892.js"><link rel="prefetch" href="/assets/js/16.a7651ec8.js"><link rel="prefetch" href="/assets/js/17.a185dc0e.js"><link rel="prefetch" href="/assets/js/18.ddc0563b.js"><link rel="prefetch" href="/assets/js/19.f7270af6.js"><link rel="prefetch" href="/assets/js/20.92bb85ea.js"><link rel="prefetch" href="/assets/js/21.89c39ef2.js"><link rel="prefetch" href="/assets/js/22.9a29a812.js"><link rel="prefetch" href="/assets/js/23.4f0942fe.js"><link rel="prefetch" href="/assets/js/24.e685798b.js"><link rel="prefetch" href="/assets/js/25.bd68738b.js"><link rel="prefetch" href="/assets/js/26.b6a14cdc.js"><link rel="prefetch" href="/assets/js/27.c7d35bfa.js"><link rel="prefetch" href="/assets/js/28.cd3e5a39.js"><link rel="prefetch" href="/assets/js/29.a08271da.js"><link rel="prefetch" href="/assets/js/3.4141285c.js"><link rel="prefetch" href="/assets/js/30.7a3f7a8c.js"><link rel="prefetch" href="/assets/js/31.1b4e43be.js"><link rel="prefetch" href="/assets/js/32.1523706b.js"><link rel="prefetch" href="/assets/js/33.feaf54cf.js"><link rel="prefetch" href="/assets/js/34.c86bb99f.js"><link rel="prefetch" href="/assets/js/35.d7f5aa35.js"><link rel="prefetch" href="/assets/js/36.892dcd4d.js"><link rel="prefetch" href="/assets/js/37.14d9e218.js"><link rel="prefetch" href="/assets/js/38.1c314a9c.js"><link rel="prefetch" href="/assets/js/39.0acd89f7.js"><link rel="prefetch" href="/assets/js/4.576c71c9.js"><link rel="prefetch" href="/assets/js/40.5bed0b53.js"><link rel="prefetch" href="/assets/js/41.0251c0f8.js"><link rel="prefetch" href="/assets/js/42.0fa512a0.js"><link rel="prefetch" href="/assets/js/43.b25ecd5e.js"><link rel="prefetch" href="/assets/js/44.edad0be5.js"><link rel="prefetch" href="/assets/js/45.ad26cbda.js"><link rel="prefetch" href="/assets/js/46.caa37496.js"><link rel="prefetch" href="/assets/js/47.76fd61f3.js"><link rel="prefetch" href="/assets/js/48.a68c6e65.js"><link rel="prefetch" href="/assets/js/49.dc64dfc0.js"><link rel="prefetch" href="/assets/js/5.41baf38a.js"><link rel="prefetch" href="/assets/js/50.8ea52489.js"><link rel="prefetch" href="/assets/js/51.89c7c756.js"><link rel="prefetch" href="/assets/js/52.bde5489c.js"><link rel="prefetch" href="/assets/js/53.40b3d92d.js"><link rel="prefetch" href="/assets/js/54.e02e40e9.js"><link rel="prefetch" href="/assets/js/55.f6e9a56b.js"><link rel="prefetch" href="/assets/js/56.5212bd81.js"><link rel="prefetch" href="/assets/js/57.dea5e4bc.js"><link rel="prefetch" href="/assets/js/58.0e2020bc.js"><link rel="prefetch" href="/assets/js/59.77fbb847.js"><link rel="prefetch" href="/assets/js/6.69372c5f.js"><link rel="prefetch" href="/assets/js/60.1d0f3147.js"><link rel="prefetch" href="/assets/js/61.14ba3b9a.js"><link rel="prefetch" href="/assets/js/62.cc561dd0.js"><link rel="prefetch" href="/assets/js/63.93810a99.js"><link rel="prefetch" href="/assets/js/64.06f05fa3.js"><link rel="prefetch" href="/assets/js/65.e956e2ca.js"><link rel="prefetch" href="/assets/js/66.4b2f1c06.js"><link rel="prefetch" href="/assets/js/67.3edb0ec6.js"><link rel="prefetch" href="/assets/js/68.ec53283a.js"><link rel="prefetch" href="/assets/js/69.7589c96b.js"><link rel="prefetch" href="/assets/js/7.30f4e943.js"><link rel="prefetch" href="/assets/js/70.0776e0e2.js"><link rel="prefetch" href="/assets/js/71.b56326fc.js"><link rel="prefetch" href="/assets/js/72.a575b0d5.js"><link rel="prefetch" href="/assets/js/73.f9678b66.js"><link rel="prefetch" href="/assets/js/74.9af8ade1.js"><link rel="prefetch" href="/assets/js/75.20c6653a.js"><link rel="prefetch" href="/assets/js/76.8a5e9868.js"><link rel="prefetch" href="/assets/js/77.b853a020.js"><link rel="prefetch" href="/assets/js/78.213a8ca8.js"><link rel="prefetch" href="/assets/js/79.e4d6ab71.js"><link rel="prefetch" href="/assets/js/80.3a34f317.js"><link rel="prefetch" href="/assets/js/81.3d47201a.js"><link rel="prefetch" href="/assets/js/82.efd990de.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.64a68e64.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f3e2e2a4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">font 文件格式文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/Digitizing_Letterform_Designs.html" class="sidebar-link">数字化字体设计</a></li><li><a href="/Converting_Outlines.html" class="sidebar-link">将轮廓转换为 TrueType 格式</a></li><li><a href="/instructing_fonts.html" class="sidebar-link">字体教程</a></li><li><a href="/Font_Engine.html" class="sidebar-link">字体引擎</a></li><li><a href="/Font_Feature_Registry.html" class="sidebar-link">字体功能注册表</a></li><li><a href="/Glyph_Mappings.html" class="sidebar-link">字符代码/字形映射</a></li><li><a href="/Graphics_State.html" class="sidebar-link">图形状态</a></li><li><a href="/Instruction_Set.html" aria-current="page" class="active sidebar-link">指令系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Instruction_Set.html#介绍" class="sidebar-link">介绍</a></li><li class="sidebar-sub-header"><a href="/Instruction_Set.html#理解指令摘要" class="sidebar-link">理解指令摘要</a></li><li class="sidebar-sub-header"><a href="/Instruction_Set.html#理解插图" class="sidebar-link">理解插图</a></li><li class="sidebar-sub-header"><a href="/Instruction_Set.html#说明" class="sidebar-link">说明</a></li></ul></li><li><a href="/Instruction_Set_Summary.html" class="sidebar-link">指令集摘要</a></li><li><a href="/words.html" class="sidebar-link">专有名词解释</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/FontTables/FontTables" class="sidebar-heading clickable"><span>字体表</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="指令系统"><a href="#指令系统" class="header-anchor">#</a> 指令系统</h1> <h2 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h2> <p>本节按字母顺序列出了 TrueType 指令集。 每个描述都从基本事实开始。 下面简要描述指令的功能。 本材料仅供参考。 有关 TrueType 语言的介绍，请参阅 Instructing Fonts 。</p> <h2 id="理解指令摘要"><a href="#理解指令摘要" class="header-anchor">#</a> 理解指令摘要</h2> <p>以下部分总结了理解后面的说明摘要所需的基本信息。</p> <h3 id="指令摘要格式"><a href="#指令摘要格式" class="header-anchor">#</a> 指令摘要格式</h3> <p>每个指令描述都以一个基本信息列表开始，如下面的图 1 所示。 对于给定的指令，仅包括相关信息字段。 例如，除了“push”指令之外的所有指令都省略了“From IS”字段。 通常，如果特定指令描述中省略了“使用”字段，则可以安全地假设该指令没有图形状态依赖性。 指令控制状态变量是该规则的一个例外。 它不会出现在每条指令的使用字段中，尽管它可以关闭所有指令的执行。</p> <p><strong>图 1 指令摘要格式</strong></p> <table><tr><td>MNEMONIC[flags]</td> <td>助记词的解释</td></tr> <tr><td>Code Range</td> <td>标识此指令及其变体的十六进制代码范围</td></tr> <tr><td>Flags</td> <td>括号内二进制数含义的解释</td></tr> <tr><td>From IS</td> <td>来自 IS 推送指令从指令流中获取的任何参数</td></tr> <tr><td>Pops</td> <td>从堆栈弹出的任何参数</td></tr> <tr><td>Pushes</td> <td>任何压入堆栈的参数</td></tr> <tr><td>Uses</td> <td>该指令所依赖的任何状态变量</td></tr> <tr><td>Sets</td> <td>此指令设置的任何状态变量</td></tr> <tr><td>Gets</td> <td>此指令检索其值的状态变量</td></tr> <tr><td>Related instructions</td> <td>任何密切相关的指令，包括具有相似或相反效果的指令</td></tr></table> <p><strong>表示堆栈相互作用</strong></p> <p>在随后的指令摘要中，将列出一条指令从堆栈弹出或压入堆栈的参数，以及它们的用途和数据类型的简要说明。
在从堆栈弹出参数的情况下，列出的第一个参数是第一个从堆栈弹出的参数，第二个是下一个弹出的参数，依此类推。</p> <table><tr><td rowspan="10">MNEMONIC[flags]</td> <td>arg3：第一个参数弹出（uint32）</td></tr> <tr><td>arg2：弹出的第二个参数（uint32）</td></tr> <tr><td>arg1：弹出第三个参数（F26Dot6）</td></tr></table> <p>在从堆栈弹出参数的情况下，第一个压入堆栈的结果首先出现，第二个压入的结果出现在它下面，依此类推。</p> <table><tr><td rowspan="10">Pushes</td> <td>result1：推送的第一个结果（F26Dot6）</td></tr> <tr><td>result2：推送的第二个结果（F26Dot6）</td></tr></table> <p>当需要总结一条指令的堆栈交互时，信息将写在一行中。 弹出的项目在两个连字符左侧的左侧，推送的项目在右侧。 上面的例子会写成：</p> <p>（arg1 arg2 arg3 -- 结果 1 结果 2）。</p> <p>列表中最右边的项目始终是堆栈顶部的项目。</p> <p><strong>堆栈中使用的数据类型</strong></p> <p>许多 TrueType 指令与解释器堆栈交互。 简单来说，它们从堆栈中获取数据并将结果返回到堆栈中。 他们操作的堆栈元素都是 32 位值。 指令解释这些值的方式各不相同。 有些人认为所有压入或弹出的 32 位都是重要的。 有些只使用某些位。 有些将 32 位数量视为带符号整数，有些将其视为无符号整数，有些则将其视为定点值。
可以出现在堆栈上的数据类型在下面的表 1 中列出。</p> <p>在压入或弹出的 32 位中只有一部分相关的情况下，数据类型的名称以大写字母 E 开头，表示“扩展”。 无符号值扩展为 32 位，有效位左侧为零。 有符号值被符号扩展为 32 位。</p> <p>定点数的名称以字母 F 开头。名称由表示数字整数部分的位数和表示二进制小数点的字母“DOT”组成。 其次是小数位数。 扩展定点数以字母 EF 开头。</p> <p>通用堆栈元素的数据类型为 StkElt。 任何 32 位数量都可以具有此数据类型。</p> <p><strong>表 1：</strong> 指令集数据类型</p> <table><thead><tr><th>数据类型</th> <th>描述</th></tr></thead> <tbody><tr><td>Eint8</td> <td>符号扩展 8 位整数</td></tr> <tr><td>Euint16</td> <td>零扩展 16 位无符号整数</td></tr> <tr><td>EFWord</td> <td>符号扩展的 16 位有符号整数，描述 FUnits 中的数量，em 空间中的最小可测量单位</td></tr> <tr><td>EF2Dot14</td> <td>符号扩展的 16 位有符号固定数，低 14 位表示小数</td></tr> <tr><td>uint32</td> <td>32 位无符号整数</td></tr> <tr><td>int32</td> <td>32 位有符号整数</td></tr> <tr><td>F26Dot6</td> <td>32 位有符号固定数，低 6 位代表小数</td></tr> <tr><td>StkElt</td> <td>任意 32 位数量</td></tr></tbody></table> <h2 id="理解插图"><a href="#理解插图" class="header-anchor">#</a> 理解插图</h2> <p>许多说明都附有插图。 这些插图中的大多数解释了指令对字形轮廓中点位置的影响。 图 1 列出了这些插图中使用的约定。 请记住，</p> <ul><li>除非另有说明，否则距离是沿投影矢量测量的</li> <li>除非另有说明，指令沿自由向量移动点
有关移动点的更多信息，请参阅 <a href="/instructing_fonts.html">字体教程</a> 。</li></ul> <p><strong>图 1</strong> 图示要点</p> <p><img src="data:image/gif;base64,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" alt=""></p> <h2 id="说明"><a href="#说明" class="header-anchor">#</a> 说明</h2> <h3 id="aa-调整角度"><a href="#aa-调整角度" class="header-anchor">#</a> AA[] 调整角度</h3> <table><tr><td>代码范围</td> <td>0x7F</td></tr> <tr><td>pops 尾部弹出</td> <td>p：点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>SANGW[ ]</td></tr></table> <p>从堆栈中弹出一个参数。 该指令是不合时宜的，没有其他作用。</p> <h3 id="abs-绝对值"><a href="#abs-绝对值" class="header-anchor">#</a> ABS[] 绝对值</h3> <table><tr><td>代码范围</td> <td>0x64</td></tr> <tr><td>pops 尾部弹出</td> <td>n：定点数（F26Dot6）</td></tr> <tr><td>Pushes 推动</td> <td>|n|：n 的绝对值 (F26Dot6)</td></tr> <tr><td colspan="10">用绝对值替换堆栈顶部的数字。</td></tr></table> <p>从堆栈弹出一个 26.6 定点数 n，并将 n 的绝对值压入堆栈。</p> <h3 id="add-添加"><a href="#add-添加" class="header-anchor">#</a> ADD[] 添加</h3> <table><tr><td>代码范围</td> <td>0x60</td></tr> <tr><td>pops 尾部弹出</td> <td>n2：定点数（F26Dot6） n1：定点数（F26Dot6）</td></tr> <tr><td>Pushes 推动</td> <td>总和：n1 + n2(F26Dot6)</td></tr> <tr><td colspan="10">将栈顶的两个数字相加。</td></tr></table> <p>从堆栈中弹出两个 26.6 定点数 n2 和 n1，并将这两个数字的和压入堆栈。</p> <h3 id="alignpts-对齐点"><a href="#alignpts-对齐点" class="header-anchor">#</a> ALIGNPTS[] 对齐点</h3> <table><tr><td>代码范围</td> <td>0x27</td></tr> <tr><td>pops 尾部弹出</td> <td>p2：点编号 (uint32) p1：点编号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>带点 p2 的 zp0 和带点 p1 的 zp1、自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>ALIGNRP[ ]</td></tr></table> <p>沿与投影向量正交的轴对齐编号为堆栈顶部两项的两个点。
从堆栈中弹出两个点数 p2 和 p1，并通过将两个点沿自由向量移动到它们沿投影向量的投影的平均值，使它们之间的距离为零。</p> <p>在下图中，点 p1 和 p2 沿着自由向量移动，直到它们之间的投影距离减小为零。 从 A 到 B 的距离等于 d/2，这等于从 B 到 C 的距离。值 d/2 是 p1 和 p2 之间原始投影距离的一半。</p> <p><img src="data:image/gif;base64,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" alt="图2"></p> <h3 id="alignrp-与参考点对齐"><a href="#alignrp-与参考点对齐" class="header-anchor">#</a> ALIGNRP[] 与参考点对齐</h3> <table><tr><td>代码范围</td> <td>0x27</td></tr> <tr><td>pops 尾部弹出</td> <td>p1、p2、...、ploopvalue：点数 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>带点 p2 的 zp0 和带点 p1 的 zp1、自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>ALIGNPTS[ ]</td></tr></table> <p>将编号位于堆栈顶部的点与 rp0 引用的点对齐。
从堆栈中弹出点编号 p1、p2、...、ploopvalue，并通过移动每个点 pi 将这些点与 rp0 的当前位置对齐，从而使从 pi 到 rp0 的投影距离减小为零。 对齐的点数取决于状态变量循环的当前设置。</p> <p>在下图中，点 p 沿着自由向量移动，直到它与 rp0 的投影距离减小为零。</p> <p><img src="data:image/gif;base64,R0lGODdhrwFAAYAAAP///wAAACwAAAAArwFAAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09XRdgbU2dvXB9wK2tja0Q/j0d0GBOLj0ujp7+3A7gbQDvzgwvH1//3o5Pr6/sr1vAf8fWIRhIsCA7hH2uGUwoxGE8bPggAjT40OK+Qf8OM2pE4lEPupEfnYTEQzJfySYn7aRkuJJIxTwjW8YsYpMOzJtHcsqh55Nnj6A65wlVQvSn0aNJkpaRuG0n0x9OxVCsOjWIN6lhoGLNCgQqG4r5uII18lWLV7Nnh4gdOy9t2x3h5FrpaHfuULZg+OpF6/dvrJl9BX/JuwSxYZyBnyhezLhvY8gsJze1TJnJ47CYM2vu7NYzGcJRNosGCfp0KNOqN7Funek1DNmwUZtMXRsKabe4c5fu3YK278TAVQgfTjxB8RDHkSePS9U5nKvSW+2uTuotdlN1l3Pwvt3xPfAYmodvyu6G+fO6yU9Yz779DPjx5c92X/8u/aX5aeL/V/5ff/oJWMp+BIoU4IENgWegglSw1qCDDz4WoYRVIFahhRd2lqGGG2rQoYcflieiISGWqMZ1KEJy4opnUMdAgi6OFlKLM15Bmo03fviQjjs+KNBBMv5oBjc+EqnWkUgmuWQkSjaJxZNQ6gbglCb6I6WVl8WYpZYywdSll5xFEKaYPARVppk4JJVmW23GENibbpojpw91zkXnkBvqGZ92LvHZ353l4SYoZTBOsVmPapIJaAkQjrfoe3kixWBNkWYgp3B+XmrBofch1JyKnHZKpwspiZOCp6N6oKqj/JnKT6NWbsrqq8FVueoJkzKnY6ESttrpNjT4quGuF2Apq0DJ/44KrAQ2EruisQ50pwO0N7aK15nL5ipsdx3txa2deD1pbZPjUrVtuFGde6So6sLqp4/l/vjtOdLCme67ICY7b7jNmtCvvhON624FAQtMsHcH60uwSrzmK/AH9ZLFa8S/ZfQvBeNAbDGmYE60QcYdTwiywQuP7GzJjC5bL8ovNHsVxy7LcC+uM6NBsZA0nzzloRGeerO2BYsAdNB77Ve00eCK3MHQSg+LEYNPAxaVyt9NTfUDPGNtr7M1c41onDKDDcJX/9JKNl15rWVp2hERCnKpY7vN5cPQ0f122dB9jXcOihm5Ts59r0korUwPvoKig0rqMOIvbzzk4Y4TzTcLgv9PDvCzlWP+Hbmbc67x5zWIDnrXd+e9tYJAzV26o6m3rjPsTMqexeu02y477rA7TfuWvePI+u+sBi9858WPeLwUurfOe/J5O/8b9NFLLx711dtqPWPNZ+838dxrvf33UJ8ufk/el286+lmrrz3767v/PPzxyz8m/Vqdb3/49geHP/3Ll/4/0AWQcwPEXAEnp7/9Ja5/8ouaAgkXpAdC8IB9S6AEXcdA9cXsgjYIXAbdR0HEhXBwI6zgB9lnQQ6SoIR4YyHdXOg2GKZNhmSjIdhSqELK5bB7O4RgDzt4Qg0GEX04/GHThlg+ahnxU0jkng2nhrYloqBtUsRXE7/3RKxHZRGKV3RiF7O3xSqKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+IxzzqcY987KMf/wjIQApykIQspCEPichEKrIkBQAAOw==" alt="图3"></p> <h3 id="and-逻辑与"><a href="#and-逻辑与" class="header-anchor">#</a> AND[] 逻辑与</h3> <table><tr><td>代码范围</td> <td>0x5A</td></tr> <tr><td>pops 尾部弹出</td> <td>e2：堆栈元素 (StkElt) e1：堆栈元素 (StkElt)</td></tr> <tr><td>Pushes 压入栈</td> <td>(e1 and e2)：e1 和 e2 的逻辑与 (uint32)</td></tr> <tr><td>使用</td> <td>带点 p2 的 zp0 和带点 p1 的 zp1、自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>OR[ ]</td></tr></table> <p>获取顶部两个堆栈元素的逻辑与。
从堆栈中弹出顶部的两个元素 e2 和 e1，并将两个元素的逻辑与结果压入堆栈。 如果其中一个或两个元素为 FALSE（值为零），则压入零。 如果两个元素都为 TRUE（具有非零值），则压入一个。</p> <h3 id="call-调用函数"><a href="#call-调用函数" class="header-anchor">#</a> CALL[] 调用函数</h3> <table><tr><td>代码范围</td> <td>0x2B</td></tr> <tr><td>pops 尾部弹出</td> <td>f：函数标识符号（0 到 (n-1) 范围内的 int32，其中 n 在“maxp”表中指定）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>FDEF[ ], EIF[ ]</td></tr></table> <h3 id="ceiling-天花板"><a href="#ceiling-天花板" class="header-anchor">#</a> CEILING[] 天花板</h3> <table><tr><td>代码范围</td> <td>0x67</td></tr> <tr><td>pops 尾部弹出</td> <td>n：定点数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>n : n 的上限 (F26Dot6)</td></tr> <tr><td>相关说明</td> <td>FLOOR[ ]</td></tr></table> <p>获取堆栈顶部数字的上限。
从堆栈中弹出一个数字 n 并压入 n ，即大于或等于 n 的最小整数值。 请注意，n 的上限虽然是一个整数值，但表示为 26.6 定点数。</p> <h3 id="cindex-将-indexed-元素复制到栈顶"><a href="#cindex-将-indexed-元素复制到栈顶" class="header-anchor">#</a> CINDEX[] 将 INDEXed 元素复制到栈顶</h3> <table><tr><td>代码范围</td> <td>0x25</td></tr> <tr><td>pops 尾部弹出</td> <td>k：堆栈元素编号（int32）</td></tr> <tr><td>Pushes 压入栈</td> <td>ek: 第 k 个堆栈元素 (StkElt)</td></tr> <tr><td rowspan="4">堆栈之前</td> <td>k：堆栈元素编号</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>...</td></tr> <tr><td>ek：堆栈元素</td></tr> <tr><td rowspan="4">堆栈之后</td> <td>ek：索引元素</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>...</td></tr> <tr><td>ek：堆栈元素</td></tr> <tr><td>相关说明</td> <td>MINDEX[ ]</td></tr></table> <p>将索引堆栈元素复制到堆栈顶部。
从堆栈中弹出堆栈元素编号 k，并将第 k 个堆栈元素的副本压入堆栈顶部。 由于它是一个被压入的副本，因此第 k 个元素保持在其原始位置。 此功能是 CINDEX[ ] 和 MINDEX[ ] 指令之间的主要区别。</p> <p>k 的零值或负值是错误的。</p> <h3 id="clear-清除堆栈"><a href="#clear-清除堆栈" class="header-anchor">#</a> CLEAR[] 清除堆栈</h3> <table><tr><td>代码范围</td> <td>0x22</td></tr> <tr><td>pops 尾部弹出</td> <td>堆栈中的所有项目 (StkElt)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr></table> <p>清除堆栈中的所有元素。</p> <h3 id="debug-调试调用"><a href="#debug-调试调用" class="header-anchor">#</a> DEBUG[] 调试调用</h3> <table><tr><td>代码范围</td> <td>0x4F</td></tr> <tr><td>pops 尾部弹出</td> <td>n：整数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr></table> <p>从堆栈中弹出一个整数。 在解释器的非调试版本中，指令的执行将继续。 在可供字体开发人员使用的调试版本中，将调用依赖于实现的调试器。
该指令仅用于调试目的，不应成为成品字体的一部分。 某些实现不支持此指令。</p> <h3 id="deltac1-delta异常c1"><a href="#deltac1-delta异常c1" class="header-anchor">#</a> DELTAC1[] DELTA异常C1</h3> <table><tr><td>代码范围</td> <td>0x73</td></tr> <tr><td rowspan="2">pops 尾部弹出</td> <td>n：异常规范和 CVT 条目号的对数 (uint32)</td></tr> <tr><td>argn, cn, argn-1,cn-1, , arg1, c1：CVT 条目号和异常规范对（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>delta 转移, delta 基础</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td></tr></table> <p>为一个或多个 CVT 值创建例外，每个 CVT 值都具有指定的磅值和指定的数量。</p> <p>弹出一个整数 n，后跟 n 对异常规范和控制值表条目号。 DELTAC1[] 更改每个 CVT 条目中指定的值，大小和像素数量在其成对参数中指定。</p> <p>DELTAC1[] 指令的 8 位 arg 组件分解为两部分。 最重要的 4 位表示应用异常的每个 em 的相对像素数。 最低有效 4 位表示要进行的更改的大小。</p> <p>每个 em 的相对像素数是参数中指定的值和增量基数的函数。 DELTAC1[] 指令以每 em 像素大小工作，从 delta base 到 delta_base + 15。要以更大的每 em 像素大小调用异常，请使用 DELTAC2[] 或 DELTAC3[] 指令，这会影响大小的变化 最多 delta_base + 47 或者，如果需要，增加 delta base 的值。</p> <p>移动的幅度在指令中以编码形式指定。 表 5 列出了异常值的映射和移动的幅度。步长的大小取决于增量偏移的值。</p> <p><strong>表 4：</strong> 映射到移动步数的幅度值</p> <table><tr><th>选择器</th> <td>0</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td></tr> <tr><th>步数</th> <td>-8</td> <td>-7</td> <td>-6</td> <td>-5</td> <td>-4</td> <td>-3</td> <td>-2</td> <td>-1</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td></tr></table> <p>有关 DELTA 指令的更多信息，请参阅 <a href="/instructing_fonts.html">字体教程</a>。</p> <h3 id="deltac2-delta异常c2"><a href="#deltac2-delta异常c2" class="header-anchor">#</a> DELTAC2[] DELTA异常C2</h3> <table><tr><td>代码范围</td> <td>0x74</td></tr> <tr><td rowspan="2">pops 尾部弹出</td> <td>n：异常规范和 CVT 条目号的对数 (uint32)</td></tr> <tr><td>argn, cn, argn-1,cn-1, , arg1, c1：CVT 条目号和异常规范对（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>delta 转移, delta 基础</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[]</td></tr></table> <p>为一个或多个 CVT 值创建例外，每个 CVT 值都具有指定的磅值和指定的数量。
弹出一个整数 n，后跟 n 对异常规范和 CVT 条目号。 DELTAC2[] 以其配对参数中指定的大小和数量更改每个 CVT 条目中的值。</p> <p>DELTAC2[] 指令与 DELTAC1[] 指令完全相同，除了以从 (delta_base + 16) 到 (delta_base + 31) 开始的每 em 像素大小操作。 要以每 em 大小的较小像素调用异常，请使用 DELTAC1[] 指令。 要以较小的每 em 像素大小调用异常，请使用 DELTAC3[] 指令，该指令可以影响最大 delta_base + 47 大小的更改，或者，如果需要，更改 delta base 的值。</p> <p>有关详细信息，请参阅 DELTAC1[] 或 <a href="/instructing_fonts.html">字体教程</a> 的条目。</p> <h3 id="deltac3-delta-异常-c3"><a href="#deltac3-delta-异常-c3" class="header-anchor">#</a> DELTAC3[] DELTA 异常 C3</h3> <table><tr><td>代码范围</td> <td>0x75</td></tr> <tr><td rowspan="2">pops 尾部弹出</td> <td>n：CVT条目号和异常规范的对数（uint32）</td></tr> <tr><td>argn, cn, argn-1,cn-1, , arg1, c1：CVT 条目号和异常规范对（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>delta 转移, delta 基础</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3[], DELTAP[], DELTAP2[], DELTAP3[]</td></tr></table> <p>为一个或多个 CVT 值创建例外，每个 CVT 值都具有指定的磅值和指定的数量。
弹出一个整数 n，后跟 n 对异常规范和 CVT 条目号。 DELTAC3[] 以其配对参数中指定的大小和数量更改每个 CVT 条目中的值。</p> <p>DELTAC3[] 指令与 DELTAC1 指令完全相同，除了以从 (delta_base + 32) 到 (delta_base + 47) 开始的每 em 像素大小操作。</p> <p>有关详细信息，请参阅 DELTAC1[] 或 <a href="/instructing_fonts.html">字体教程</a> 的条目。</p> <h3 id="deltap1-delta异常p1"><a href="#deltap1-delta异常p1" class="header-anchor">#</a> DELTAP1[] DELTA异常P1</h3> <table><tr><td>代码范围</td> <td>0x5D</td></tr> <tr><td>Pops n：异常规范和点数对（uint32）</td> <td>argn, pn, argn-1, pn-1, , arg1, p1：n 对异常规范和点（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0, delta base, delta shift, 自由向量, 投影向量</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td></tr></table> <p>在一个或多个点位置创建异常，每个位置都具有指定的点大小和指定的数量。
DELTAP1[] 作用于 zp0 引用的区域中的点。 它以配对参数中指定的大小和数量移动指定的点。 移动一个点可以打开或关闭位图中选定的像素，这些像素将在扫描转换受影响的轮廓时创建。 可以指定任意数量的点和参数。</p> <p>分组 [argi, pi] 可以执行 n 次。 argi 的值由一个字节组成，低四位表示异常的大小，高四位表示每个 em 值的相对像素。</p> <p>DELTAP 指令工作的实际每 em 像素大小是相对每 em 像素大小和 delta base 的函数。 DELTAP1[] 指令以每 em 像素大小工作，从 delta_base 到 delta_base + 15。要在每 em 更大像素大小上调用异常，请使用 DELTAP2[] 或 DELTAP3[] 指令，它们一起可以影响更改 大小最大为 delta_base + 47，或者，如果需要，增加 delta base 的值。</p> <p>移动的幅度在指令中以编码形式指定。 表 5 列出了从 DELTA 指令中使用的异常值到移动步长的映射。 步长的大小取决于增量偏移的值。</p> <p><strong>表 5：</strong> 映射到移动步数的幅度值</p> <table><tr><th>选择器</th> <td>0</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td></tr> <tr><th>步数</th> <td>-8</td> <td>-7</td> <td>-6</td> <td>-5</td> <td>-4</td> <td>-3</td> <td>-2</td> <td>-1</td> <td>1</td> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td></tr></table> <h3 id="deltap2-delta-异常-p2"><a href="#deltap2-delta-异常-p2" class="header-anchor">#</a> DELTAP2[] DELTA 异常 P2</h3> <table><tr><td>代码范围</td> <td>0x71</td></tr> <tr><td>Pops n：异常规范和点数对（uint32）</td> <td>argn, pn, argn-1, pn-1, , arg1, p1：n 对异常规范和点（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0, delta shift, delta base, 自由向量, 投影向量</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td></tr></table> <p>在一个或多个点位置创建异常，每个位置都具有指定的点大小和指定的数量。
DELTAP2[] 作用于 zp0 引用的区域中的点。 它以配对参数中指定的大小和数量移动指定的点。 移动一个点可以打开或关闭位图中选定的像素，这些像素将在扫描转换受影响的轮廓时创建。 可以指定任意数量的点和参数。</p> <p>DELTAP2[] 指令与 DELTAP1[] 指令相同，除了以从 (delta_base + 16) 到 (delta_base + 31) 开始的每 em 像素大小进行操作。 要以每 em 大小的较小像素调用异常，请使用 DELTAP1[] 指令。 要以每 em 大小的较小像素调用异常，请使用 DELTAP3[] 指令。 如有必要，更改 delta_base 的值。</p> <h3 id="deltap3-delta-异常-p3"><a href="#deltap3-delta-异常-p3" class="header-anchor">#</a> DELTAP3[] DELTA 异常 P3</h3> <table><tr><td>代码范围</td> <td>0x71</td></tr> <tr><td>Pops n：异常规范和点数对（uint32）</td> <td>argn, pn, argn-1, pn-1, , arg1, p1：n 对异常规范和点（uint32 对）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0, delta shift, delta base, 自由向量, 投影向量</td></tr> <tr><td>相关说明</td> <td>DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td></tr></table> <p>在一个或多个点位置创建异常，每个位置都具有指定的点大小和指定的数量。
弹出一个整数 n，后跟 n 对异常规范和点。 DELTAP3[] 作用于 zp0 引用的区域中的点。 它以配对参数中指定的大小和数量移动指定的点。 移动一个点可以打开或关闭位图中选定的像素，这些像素将在扫描转换受影响的轮廓时创建。 可以指定任意数量的点和参数。</p> <p>DELTAP3[] 指令与 DELTAP1[] 指令相同，除了以从 (delta_base + 32) 到 (delta base + 47) 开始的每 em 像素大小进行操作。 要以每 em 大小的较小像素调用异常，请使用 DELTAP1[] 或 DELTAP2[] 指令。 如有必要，更改增量基数的值。</p> <h3 id="depth-栈的深度"><a href="#depth-栈的深度" class="header-anchor">#</a> DEPTH[] 栈的深度</h3> <table><tr><td>代码范围</td> <td>0x24</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>n：元素数量（int32）</td></tr></table> <p>将 n（当前在堆栈中的元素数）压入堆栈。</p> <h3 id="div-除法"><a href="#div-除法" class="header-anchor">#</a> DIV[]除法</h3> <table><tr><td>代码范围</td> <td>0x62</td></tr> <tr><td rowspan="2">Pops</td> <td>n2：小数 (F26Dot6)</td></tr> <tr><td>n1：最后一个小数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>(n1 * 64)/n2：商 (F26Dot6)</td></tr></table> <p>将堆栈顶部的第二个数除以堆栈顶部的数字。
从堆栈中弹出两个 26.6 定点数 n1 和 n2，并将 n2 除以 n1 得到的商压入堆栈。 除法按以下方式进行，n1 左移六位，然后除以 2。</p> <h3 id="dup-duplicate-栈顶元素"><a href="#dup-duplicate-栈顶元素" class="header-anchor">#</a> DUP[] DUPlicate 栈顶元素</h3> <table><tr><td>代码范围</td> <td>0x20</td></tr> <tr><td>Pops</td> <td>e：堆栈元素（StkElt）</td></tr> <tr><td>Pushes 压入栈</td> <td>e：堆栈元素（StkElt）</td></tr> <tr><td>e：堆栈元素（StkElt）</td> <td></td></tr></table> <p>复制栈顶元素。
从堆栈中弹出一个元素 e，复制该元素并将其压入两次。</p> <h3 id="eif-end-if"><a href="#eif-end-if" class="header-anchor">#</a> EIF[] End IF</h3> <table><tr><td>代码范围</td> <td>0x59</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>IF[ ], ELSE[ ]</td></tr></table> <p>标记 IF 或 IF-ELSE 指令序列的结束。</p> <h3 id="else-else-子句"><a href="#else-else-子句" class="header-anchor">#</a> ELSE[] ELSE 子句</h3> <table><tr><td>代码范围</td> <td>0x1B</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>IF[ ], ELSE[ ]</td></tr></table> <p>标记当 IF 指令在堆栈上遇到 FALSE 值时要执行的指令序列的开始。 该指令序列以 EIF 指令结束。</p> <p>IF-ELSE-EIF 序列的 ELSE 部分是可选的。</p> <h3 id="endf-end-函数定义"><a href="#endf-end-函数定义" class="header-anchor">#</a> ENDF[] END 函数定义</h3> <table><tr><td>代码范围</td> <td>0x2D</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>FDEF[ ], IDEF[ ]</td></tr></table> <p>标记函数定义或指令定义的结尾。 函数定义和指令定义不能嵌套。</p> <h3 id="eq-相等"><a href="#eq-相等" class="header-anchor">#</a> EQ[] 相等</h3> <table><tr><td>代码范围</td> <td>0x54</td></tr> <tr><td>Pops</td> <td>e2：堆栈元素 e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>相关说明</td> <td>NEQ[ ]</td></tr></table> <p>测试栈顶的两个数是否相等。
从堆栈中弹出两个 32 位值 e2 和 e1 并比较它们。 如果它们相同，则将一个表示 TRUE 的值压入堆栈。 如果它们不相等，则将零（表示 FALSE）放入堆栈。</p> <h3 id="even-even"><a href="#even-even" class="header-anchor">#</a> EVEN[] EVEN</h3> <table><tr><td>代码范围</td> <td>0x57</td></tr> <tr><td>Pops</td> <td>e: 堆栈元素 (F26Dot6)</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>使用</td> <td>圆形状态</td></tr> <tr><td>相关说明</td> <td>ODD[ ]</td></tr></table> <p>测试堆栈顶部的数字在根据舍入状态舍入时是否为偶数。
从堆栈中弹出一个 26.6 的数字 e，并根据当前轮次状态对该数字进行四舍五入。 然后将该数字截断为整数。 如果被截断的数字是偶数，则表示 TRUE 的 1 被压入堆栈； 如果它是奇数，则将零（表示 FALSE）放入堆栈。</p> <h3 id="fdef-函数定义"><a href="#fdef-函数定义" class="header-anchor">#</a> FDEF[] 函数定义</h3> <table><tr><td>代码范围</td> <td>0x2C</td></tr> <tr><td>Pops</td> <td>f：函数标识符号（0 到 (n-1) 范围内的整数，其中 n 在“maxp”表中指定</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关说明</td> <td>ENDF[ ], CALL[ ]</td></tr></table> <p>标记函数定义的开始，并从堆栈中弹出一个数字 f 以唯一标识此函数。 当在指令流中遇到 ENDF[] 时，该定义将终止。 函数定义只能出现在字体程序或 CVT 程序中。 函数必须先定义，然后才能与 CALL[ ] 指令一起使用。</p> <h3 id="flipoff-将自动-flip-布尔值设置为-off"><a href="#flipoff-将自动-flip-布尔值设置为-off" class="header-anchor">#</a> FLIPOFF[] 将自动 FLIP 布尔值设置为 OFF</h3> <table><tr><td>代码范围</td> <td>0x4E</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自动翻转</td></tr> <tr><td>影响</td> <td>MIRP、MIAP</td></tr> <tr><td>相关指令</td> <td>FLIPON[ ], MIRP[ ], MIAP[ ]</td></tr></table> <p>将图形状态中的自动翻转布尔值设置为 FALSE，导致 MIRP[] 和 MIAP[] 指令使用控制值表条目的符号。 当自动翻转设置为 FALSE 时，测量距离的方向变得很重要。 自动翻转状态变量的默认值为 TRUE。</p> <h3 id="flipon-将自动-flip-布尔值设置为-on"><a href="#flipon-将自动-flip-布尔值设置为-on" class="header-anchor">#</a> FLIPON[] 将自动 FLIP 布尔值设置为 ON</h3> <table><tr><td>代码范围</td> <td>0x4D</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自动翻转</td></tr> <tr><td>影响</td> <td>MIRP、MIAP</td></tr> <tr><td>相关指令</td> <td>FLIPOFF[ ], MIRP[ ], MIAP[ ]</td></tr></table> <p>将图形状态中的自动翻转布尔值设置为 TRUE，导致 MIRP[] 和 MIAP[] 指令忽略控制值表条目的符号。 当自动翻转变量为 TRUE 时，测量距离的方向变得无关紧要。 自动翻转状态变量的默认值为 TRUE。</p> <h3 id="flippt-翻转点"><a href="#flippt-翻转点" class="header-anchor">#</a> FLIPPT[] 翻转点</h3> <table><tr><td>代码范围</td> <td>0x80</td></tr> <tr><td>Pops</td> <td>p1, p2, , ploopvalue: 点数 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0，循环</td></tr> <tr><td>相关说明</td> <td>FLIPRGON[ ], FLIPRGOFF[ ]</td></tr></table> <p>使曲线上的点成为曲线外点或使曲线外的点成为曲线上的点。
从堆栈中弹出点 p、p1、p2、...、ploopvalue。 如果 pi 是曲线上的点，则它是曲线外的点。 如果 pi 是曲线外点，则它是曲线上点。 没有点 pi 被标记为已触摸。 因此，所有翻转点都不会受到 IUP[ ] 指令的影响。 FLIPPT[ ] 指令重新定义字形轮廓的形状。</p> <h3 id="fliprgoff-flip-range-关闭"><a href="#fliprgoff-flip-range-关闭" class="header-anchor">#</a> FLIPRGOFF[] FLIP RanGe 关闭</h3> <table><tr><td>代码范围</td> <td>0x80</td></tr> <tr><td rowspan="2">Pops</td> <td>h：范围内的高点数（uint32）</td></tr> <tr><td>l：范围内的低点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0</td></tr> <tr><td>相关说明</td> <td>FLIPPT[ ], FLIPRGOFF[ ]</td></tr></table> <p>将指定范围内的所有点更改为曲线外点。
弹出定义点范围的两个数字，第一个是高点，第二个是低点。 此范围内的曲线上点将成为曲线外点。 点的位置不受影响，因此点不标记为触摸。</p> <h3 id="fliprgon-flip-range-开启"><a href="#fliprgon-flip-range-开启" class="header-anchor">#</a> FLIPRGON[] FLIP RanGe 开启</h3> <table><tr><td>代码范围</td> <td>0x81</td></tr> <tr><td rowspan="2">Pops</td> <td>h：翻转范围内的高点数（uint32）</td></tr> <tr><td>l：翻转范围内的低点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0</td></tr> <tr><td>相关说明</td> <td>FLIPPT[ ], FLIPRGOFF[ ]</td></tr></table> <p>使指定范围内的所有点成为曲线上的点。
弹出定义点范围的两个数字，第一个是高点，第二个是低点。 此范围内的曲线外点将变为曲线上点。 点的位置不受影响，因此点不标记为触摸。</p> <h3 id="floor-floor"><a href="#floor-floor" class="header-anchor">#</a> FLOOR[] FLOOR</h3> <table><tr><td>代码范围</td> <td>0x66</td></tr> <tr><td>Pops</td> <td>n：需要 floor 的号码（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>n : n 层 (F26Dot6)</td></tr> <tr><td>相关说明</td> <td>CEILING[ ]</td></tr></table> <p>获取堆栈顶部值的底部。</p> <p>从堆栈中弹出一个 26.6 定点数 n 并返回 n ，即小于或等于 n 的最大整数值。 请注意，n 的下限虽然是一个整数值，但表示为 26.6 定点数。</p> <h3 id="gc-a-获取投影到投影向量上的坐标"><a href="#gc-a-获取投影到投影向量上的坐标" class="header-anchor">#</a> GC[a] 获取投影到投影向量上的坐标</h3> <table><tr><td>代码范围</td> <td>0x46 - 0x47</td></tr> <tr><td rowspan="2">a</td> <td>0：使用点p的当前位置</td></tr> <tr><td>1：使用原轮廓中p点的位置</td></tr> <tr><td>Pops</td> <td>p: 点号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>c：坐标位置（F26Dot6）</td></tr> <tr><td>使用</td> <td>zp2，投影向量，双投影向量</td></tr> <tr><td>相关说明</td> <td>SCFS[ ]</td></tr></table> <p>使用当前投影向量获取指定点的坐标值。
弹出一个点号 p 并将该点在当前投影向量上的坐标值压入堆栈。 GC[] 返回的值取决于投影向量的当前方向。</p> <p>下图，GC[1]，p1 在栈顶，返回点 p1 的原始位置，而 GC[0]，p2 在栈顶，返回点 p2 的当前位置。</p> <p><img src="data:image/gif;base64,R0lGODdhoAFlAYAAAP///wAAACwAAAAAoAFlAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9uLGQAM7DtMXGx8XBeMvAwSYKDMHI3hDEBNLY0tYV2d3R2hDO0trnA9br5Qfq6+zk4enN6eLRwejz3vDF+/DE2vv8+NL5+/Ye+sCRy4692zggiJ9XvGrSHBBwcl0qp4QJjFXP8aIWDc2KqjR5DSRJKEZXLkSVkfya1kaSHly1QyVc5E1fJmrZw6Zz3sectgzW9AR6Xj6bJoqKMZkCqNxFDD0KeaphKlKsppUqy4rHINVPCnCK1fE5FtcLZsIa8U2KpVlPbtJLFyVQlFV9fUtogZ4+Z9tA2eX7SD/64BJ9LthcKG0xxkjLYx2L6UTSiWLCfs5aaYAZXbzLmzH6YpQItWYxKyzdN5PqumyHoP4til6NK+jTu37tW7PZnu7eg18EHCh4MtbvwP8uR9ljOX7fx5a+nUq1u/jj27uuja4XDv7uY3+ObjIX0vj/o8ejTq15tpXw2+exzi29qen8x1ffxs7vL/J37ff3dEJSB7TYUjX4E/kPVQggr2gJRCD77hlYQTxvFYgBc6hs5+G4LRkYUfHpahhiOSIZCJJ5ZxFDgrZhaQhy96IeKMMMpo4xYS4phjFTXy1SN7dFXUII9B3qAiXhBlxOSRTPyojZJbOWkElG1NiYCDVEqVJAMEprglEV2uBmaY9Ak25lXx8bOmkWZK1Zebbz5p5ZxipGmnFQppmeeZifUZBpR8AgoDnoRGUeehWiSqKBaMNppEhXJCmkOJg1JamjuTYrpDiJtyCuGjoEIh6qhO7HmpqSj0k6qqIwjqKqm2tRorl5/WaoOhuAZR6q5V6uprqLcGq0JqwxLLglC0/yLbQa/MAkHgs0sgKK0SNS5brTbAZkuDs9x2euy3lm0rbjNhERZuufYlYGy66q7rzkLYvrsQuvPSu2S9WeILYZbU8tupv58BHLC/+xKca53uIuwlgvkszDC7MhkbsQuJalbxCt5mXCy5HI8F8cdYtilyt3HeW3G0JXcb8sr2AunyCyKiDPDGMb/a8s0S56yzvDRHbHPPUVLEM8c1BS10TDv/XLPPSR98cghIM5wayEXvSlqzbD4tpby2tvg0PWXaNxTTio79TYVcJ+WfRx6vre3VN08Nd0xyZ/zw23VPSffebve9KuCc6u23vXdPQHifM4sJ0eH/wTrEXmZnN+vkS//uFauolq/ZpKnObr65dDY7DpurwIY+KuCoUyp4ESorHig+8RV+QkD54su0RoljmrvspNv4u8ReE9z77oPTnuzPwR+p/MfNG7068eAiXyz1pUXPL/a469zq8nOm6v332m8fw/g5Omi8tHJ+ZH6QjN2D7t4yYk5Z+KxzoLvA1n9g0P4k6N4+bvXPf/i7BvwIaLAKDAyBXkJcAE2nLQbCS4JSc4D96FU2Ck6jYRpcTAfNJbwPNkuEHnggCZNmQvXp64R2gxkLr5TCzJ0rTi9czOtqaMEE4pCG7OrhDptku6r98HJErMwQJee1C5brX8Mb4u2cyBsoSnGKVKyiFa+IxSxPanGLXOyiF78IxjCKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+IxzzqcY987KMf/wjIQApykIQspCEPichEKnKRjGykIx8JSVQUAAA7" alt="F025_instr4"></p> <h3 id="getinfo-获取信息"><a href="#getinfo-获取信息" class="header-anchor">#</a> GETINFO[] 获取信息</h3> <table><tr><td>代码范围</td> <td>0x88</td></tr> <tr><td>Pops</td> <td>选择器：整数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>结果：整数（uint32）</td></tr></table> <p>用于获取有关呈现字体的 TrueType 引擎版本的数据以及当前字形的特征。 该指令弹出一个用于确定所需信息类型的选择器，并将结果压入堆栈。
在选择器中设置位 0 请求引擎版本。 设置位 1 询问字形是否已旋转。 设置位 2 询问字形是否已被拉伸。 要请求有关这些值中的两个或更多个的信息，请设置适当的位。 例如，选择器值 6 (0112) 请求有关旋转和拉伸的信息。</p> <p>结果与请求的信息一起被压入堆栈。 结果的第 0 位到第 7 位包含字体引擎版本号。 表 0-2 中列出了版本号。</p> <p>如果当前字形已旋转，则位 8 设置为 1。 否则为 0。 位 9 设置为 1 以指示字形已被拉伸。 否则为 0。</p> <p><strong>表 0-1</strong> 选择器位和产生的结果</p> <p><strong>表 6</strong></p> <table><thead><tr><th>选择位</th> <th>意义</th> <th>结果位</th></tr></thead> <tbody><tr><td>0</td> <td>获取引擎版本</td> <td>0-7</td></tr> <tr><td>1</td> <td>旋转？</td> <td>8</td></tr> <tr><td>2</td> <td>拉伸？</td> <td>9</td></tr></tbody></table> <p>表 0-2 中给出了引擎版本的可能值。</p> <p><strong>表 0-2</strong> 字体引擎版本号</p> <table><thead><tr><th>系统</th> <th>引擎版本</th></tr></thead> <tbody><tr><td>Macintosh System6.0</td> <td>1</td></tr> <tr><td>Macintosh System7.0</td> <td>2</td></tr> <tr><td>Windows 3.1</td> <td>3</td></tr> <tr><td>KanjiTalk 6.1</td> <td>4</td></tr></tbody></table> <p>如果 TrueType 引擎是 System 7.0 版本，并且选择器请求有关版本号、旋转和拉伸的信息，并且字形旋转但未拉伸，则结果将为 01 0000 00102 或 258。</p> <h3 id="gfv-获取自由向量"><a href="#gfv-获取自由向量" class="header-anchor">#</a> GFV[] 获取自由向量</h3> <table><tr><td>代码范围</td> <td>0x0D</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td rowspan="2">Pushes 压入栈</td> <td>px: x 分量 (EF2Dot14)</td></tr> <tr><td>py：y 分量 (EF2Dot14)</td></tr> <tr><td>获取</td> <td>自由向量</td></tr> <tr><td>相关说明</td> <td>GPV[ ]</td></tr></table> <p>将当前自由向量分解为其 x 和 y 分量，并将这些分量作为两个 2.14 数字放入堆栈。 这些数字占据每个 long 的最低有效两个字节。</p> <p>压入的第一个分量 px 是自由向量的 x 分量。 第二个推入的 py 是自由向量的 y 分量。 每个都是一个2.14的数字。</p> <p>GFV[] 将自由向量视为源自网格原点的单位向量。 在下图中，A 点到 B 点的距离为 1 个单位。</p> <p><img src="data:image/gif;base64,R0lGODdhSgFyAYAAAP///wAAACwAAAAASgFyAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV1tfY2drb3N3e0NEBDwHRc+Dld+iD4crk4oXsz+Pti+zl4oTxxPb26mj++3T5g/fmns2QN34B+dgMb+iVO40JlDhHggInNokVzGhv8JNhL0MvEOw2TyRn784lFOymMr35gkuacly5jVZKqxObPiNZwnt/As85OjnaDw6hAVOudoUZVKl5Lr1rTnlKhYXk6jegVrPpdat7rp6pUN2LA3x66TenONVWxm0SZp+7Yn3CNrs80tcpcsmbxn3Z7hCwRwX79Aqxx0IFgvlHceE6cKis/xCsYNFEaVnM7AYQklDZsM2QHzPYqkI3SmQpnzB9HzNCfsODL1VNcK6JW0uhkB60CyQ1qULSU34telFwAn3qp3R9q1mfuEeLqxc+SslOueTnz3i9/ZHxzHroqxOvHcwaP+rJnhbeixyneOnN7fYfnxEtIff389ffv3+ev/G17aQ8i9R50rGxHonHaTvSTgdca99l0vGSmYQn0WrERhJRNyUdd1KWVIyYZZ5QWiJAdWVaE0JYqw4mBTtSgQhzDuMuMG+3T4UY0s6ogLjxf85qMtQVYAJGEMDKlaZUjOsiQEBzbZ3hMfQgkLlQ96Z6WBMhp55RJZStjEl7x8iSOXXSIhJphxUVAmP1aW2aY5aU4Q5zhQxlnnN3dikKc3TRLVJ1R4ATrnY0QoFSg3Qwaa6DaFmvboKT42auaZlYIU2KUk8Bipizp0RaldPoDaaSmlKqmpeTSMFSpbW6a6Ylut7vRpCbNaA+Ktup06Sq4n6EoNr8YJGwqFwKZqKbJZ/2h3rLLNzUAsTDII1mw0rFULG7LR7qotDNjWtq0n4abXrQuYfSuRueeOy0li17K7CbXvlqsFus0ABi8z+dJrwr76puhsDXPl6u8lA+Ng77+bflqwJbIyzG9VDWs4QsJ0ThxixTxYrAypPXAs7WqjYjyJVjqCfNFqJD+zMmGXtcxyaAEH0dSiMD+CqM0REznozhf3DOurmkJG182OsItyTmy+ZXQjPL3ZNCM2kRn1IlPPvCbWWSWpNV1db42lE0kjVZmUVSvy5GJnJ3Ki2j579vbYm66NCNJ0Z5btizvzKrdewvbtIuBfh2bh4GHid/dO7BnO9JHEVitcMGnD3e9/gf+38/dd+zmdX+eef255fLuCTnrppp+Oeur5/RIZfnxszrqIegykWIFW/DRl4vVaJjgKU6OjOxr1RW4YnRBqQ3zxopdNW/BhlMdhd0dKD6DzZk/fRXTMU4Sh9VIWp6ry3G8f4bOsg7cvedgfhCH4uhTuYPYJkrZ49efb7m+Dti8XM/7Co9Uy/eWIcbMhYBS8hzwDHlCBi2Hg9xwYJghGUIJeomAFLZg1DBoBgaLSoNc8uEEQhlCEhyJhCU0oBA66CoU0Y2ELXfgDFdIKhqOiYQ1tuDEc5lCHteJhDmSIKx/+UIgII+INgFgTI9oAiUpsohOfCMUoSnGKVKyiFa+IxSxianGLXOyiF78IxjCKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+IxzzqcY987KMf/wjIQApykIQspCEPichEKnKRjGykIx8JyUhKcpKUrKQlL4nJTGpyk5zspCd1UQAAOw==" alt="F025_instr5"></p> <h3 id="gpv-get-projection-vector-获取投影向量"><a href="#gpv-get-projection-vector-获取投影向量" class="header-anchor">#</a> GPV[] Get Projection Vector 获取投影向量</h3> <table><tr><td>代码范围</td> <td>0x0C</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td rowspan="2">Pushes 压入栈</td> <td>p<sup>x</sup>: x 组件 (EF2Dot14)</td></tr> <tr><td>p<sup>y</sup>：y 组件 (EF2Dot14)</td></tr> <tr><td>获取</td> <td>投影矢量</td></tr> <tr><td>相关说明</td> <td>GFV[ ]</td></tr></table> <p>将当前投影向量分解为其 x 和 y 分量，并将这些分量作为两个 2.14 数字压入堆栈。
压入的第一个分量 px 是投影向量的 x 分量。 第二个压入的 py 是投影向量的 y 分量。</p> <p>GPV[] 将投影矢量视为源自网格原点的单位矢量。 在下图中，A 点到 B 点的距离是一个单位。</p> <p><img src="data:image/gif;base64,R0lGODdhgwFKAYAAAP///wAAACwAAAAAgwFKAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3srERCAy8uh2wuM8RtMnDtcjNyge5zcfLC86ywNHS3dTF1tXYytjbwM8A3+3H1bvWsuTt6bLc6uXsvO/G4bP7+e4G4/a56vL9vvD17AYAAH/jN4DyGuggpdMWzI6iFEVRInoqpo0RTGjP+kNnIU5fEjqJAiPZEsyekkSk0qV2Jq6dISzJiUZtKUZPMmpJw6HfHsyegnUEVChyIqatQQ0qSEljIV5PQpoKhS/VCtyucqVj1at+Lp6tUO2LB0xpKVY/YsnLRq3bBty+YtXDVy56Kpa9cM3rxk9vIV4/cvmMCCvRAuzOUwYi2KF2Np7NgK5MhUJlOWYvkylMyanXDuzOQzaCWiRyMpbdoI6tREVrMWUtD1tAuySQCU53hjuNoibqejjBEd7xD9og0n+Aw3AnS/wxQPF5m5bwPG+y7IdjxhuunbrSvADnxcc3zis3cw3834sHPl14/h9rr78vnfnTNTDpo9fWWAr6P/V6cfXc8NAV18L+BHXWvQGOgCdtCthg2CcURIYYUWXohhhhpuyGGHHn7I4XL3gUhiiRcyiMIxBUIYIYoq3MZigcT81wKCMVpD4wrUfJcjMD2e8CA/P2r3hozgLPjakL3FtkR1ySj5gZHkNQnlhG1IWV+TswkYnJZVriVgBcc5+eRdEjLwpYvGnJSmmg+c+aabg8EZp5yJ0QlBm+XMGSWDeor4058CbYGlBoLS8ieeFhy6TxaF+uLnFY+eF2kVihpaKWaXYmrgj5MSl6lnaTGa26YekFrYpyWg+pepoNqp4F6svsKbqinM6tARrq4aahC26tirDkLugGsrnP2y663B/wqbrLKd+oBkD8VGJC2ZPEy7CmQP/oAtRTn8akO3LjUbg7glgYuDuRyh+y2sNZqnrkblkhvusinSe0O8pZjFLrf22jakvh29iC+x/0ZZ8LUHn5emwKM41a9qCwuTMBAOg7RkFxdvUzFs7tLWMYEfiznrxguFXITJn6gUcRQqm0TxGS93ElLLU8ycEgU2VzZxcnH1vLNkCwct6WgrOoAyZkYnyDSPKrtDEs55VBdgcjPXg67Ud+zmn1j4MJfLU1Q7qDV4YFNnI1NOIpu0o/OdLV+WRq3YNmNvi1ceml6daHWLfcOHNoWA+h044UcK/veOiSueINzW7ic223tgrWLgev9Xdd/kU07JZOTxaI136JsHCHodRtpUsjDjJaUcT6yyjDl+rjuXQellpX04pF/APveZa7+Ju2Gq9x7B70g3vbnGgtlqPH+rI58YX1nnfvnj0Edvl6tVb2/5dbTD1bI8xd39PKFtEZ085FV/TxbK61/u3d51h12G7V/NPwG29otFWLf7z4E+qHgOZqz7H5B6Z8AD9iSAR1lgAl90EwYSJSYSXMQDAXPBGqGkgo3I4J082KCP4M+CGeFgJEBoqRF2MCCfQxQL1YNCGsSwCdFy4Qt5MUPS1NCG79jWnnqYQ2EBSIWZCOJljBiekSlxiUxsohOfCMUoSnGKVKyiFa+IxSx0anGLXOyiF78IxjCKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+IxzzqcY987KMf/wjIQApykIQspCEPichEKnKRjGykIx8JyUhKcpKUrKQlL4nJTGpyk5zspCc/CcpQinKUpCylKU+JylSqcpWwKgAAOw==" alt="F025_instr6"></p> <h3 id="gt-大于"><a href="#gt-大于" class="header-anchor">#</a> GT[] 大于</h3> <table><tr><td>代码范围</td> <td>0x52</td></tr> <tr><td>Pops</td> <td>e2：堆栈元素 e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>相关指令</td> <td>LT[ ], GTEQ[ ]</td></tr></table> <p>比较顶部两个堆栈元素的大小。
从堆栈中弹出两个整数 e2 和 e1 并比较它们。 如果 e1 大于 e2，则表示 TRUE 的 1 被压入堆栈。 如果 e1 不大于 e1，则表示 FALSE 的零被放入堆栈。</p> <h3 id="gteq-大于或等于"><a href="#gteq-大于或等于" class="header-anchor">#</a> GTEQ[] 大于或等于</h3> <table><tr><td>代码范围</td> <td>0x53</td></tr> <tr><td>Pops</td> <td>e2：堆栈元素 e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>相关指令</td> <td>LTEQ[ ], GT[ ]</td></tr></table> <p>比较顶部两个堆栈元素的大小。
从堆栈中弹出两个整数 e2 和 e1 并比较它们。 如果 e1 大于或等于 e2，则表示 TRUE 的 1 被压入堆栈。 如果 e1 不大于或等于 e1，则表示 FALSE 的零被放入堆栈。</p> <h3 id="idef-指令定义"><a href="#idef-指令定义" class="header-anchor">#</a> IDEF[] 指令定义</h3> <table><tr><td>代码范围</td> <td>0x89</td></tr> <tr><td>Pops</td> <td>操作码 (Eint8)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>ENDF[ ]</td></tr></table> <p>开始指令的定义。 该指令由弹出的操作码标识。 IDEF[ ] 指令的目的是允许旧版本的缩放器使用使用在以后版本的 TrueType 解释器中定义的指令的字体。 引用未定义的操作码将无效。 IDEF[ ] 不适用于创建用户定义的指令。 FDEF[ ] 应该用于该目的。
当在指令流中遇到 ENDF[ ] 时，以 IDEF[ ] 开始的指令定义终止。 不允许嵌套的 IDEF。 弹出的操作码的后续执行将定向到该指令定义的内容。 IDEF 应在字体程序中定义。 不建议在 CVT 程序中定义指令。</p> <h3 id="if-if-test"><a href="#if-if-test" class="header-anchor">#</a> IF[] IF test</h3> <table><tr><td>代码范围</td> <td>0x58</td></tr> <tr><td>Pops</td> <td>e：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>ELSE[ ], EIF[ ]</td></tr></table> <p>标记 if 语句的开始。
从堆栈中弹出一个整数 e。 如果 e 为零 (FALSE)，指令指针将移动到指令流中关联的 ELSE 或 EIF[] 指令。 如果 e 为非零 (TRUE)，则执行指令流中的下一条指令。 执行将继续，直到遇到关联的 ELSE[] 指令或关联的 EIF[] 指令结束 IF[] 语句。 如果在 EIF[] 之前找到关联的 ELSE[] 语句，则指令指针将移至 EIF[] 语句。</p> <h3 id="instctrl-instruction-执行控制"><a href="#instctrl-instruction-执行控制" class="header-anchor">#</a> INSTCTRL[ ] INSTRuction 执行控制</h3> <table><tr><td>代码范围</td> <td>0x8E</td></tr> <tr><td>Pops</td> <td>s：选择器（int32） v：指令控制值（int32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>指令控制</td></tr></table> <p>设置指令控制状态变量，可以打开或关闭指令的执行并调节 CVT 程序中设置的参数的使用。</p> <p>该指令清除和设置各种控制标志。 选择器用于选择相关标志。 该值决定了该标志的新设置。</p> <p>在 1.0 版中，只使用了两个标志。</p> <p>标志 1 用于禁止网格拟合。 选择器值为 1。如果此标志设置为 TRUE (v=1)，则不会执行与字形相关的任何指令。 如果标志为 FALSE (v=0)，指令将被执行。 例如，要在旋转或拉伸字形时禁止网格调整，请在预编程中使用以下序列：</p> <table><tr><td>PUSHB[000] 6</td> <td>/* 要求 GETINFO 检查拉伸或旋转 */</td></tr> <tr><td>GETINFO[ ]</td> <td>/* 如果字形被拉伸或旋转，将推送 TRUE */</td></tr> <tr><td>IF[]</td> <td>/* 测试栈顶的值 */</td></tr> <tr><td>PUSHB[000] 1</td> <td>/* INSTCTRL 的值 */</td></tr> <tr><td>PUSHB[000] 1</td> <td>/* INSTCTRL 选择器 */</td></tr> <tr><td>INSTCTRL[]</td> <td>/* 基于选择器和值将关闭网格匹配 */</td></tr> <tr><td colspan="2">EIF[]</td></tr></table> <p>标志 2 用于确定在执行与字形相关的指令时应忽略 CVT 程序中设置的任何参数。 这些包括，例如，扫描类型和 CVT 切入的值。 当 flag2 设置为 TRUE 时，将使用这些参数的默认值，而不管预编程对这些值所做的任何更改。 当 flag2 设置为 FALSE 时，由 CVT 程序更改的参数值将用于字形指令。</p> <p>INSTCTRL[] 只能在 CVT 程序中执行。</p> <h3 id="ip-interpolate-point-插值点"><a href="#ip-interpolate-point-插值点" class="header-anchor">#</a> IP[] Interpolate Point 插值点</h3> <table><tr><td>代码范围</td> <td>0x39</td></tr> <tr><td>Pops</td> <td>p1, p2, , ploopvalue: 点数 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>带 rp1 的 zp0、带 rp2 的 zp1、带点 p 的 zp2、循环、自由向量、投影向量、双投影向量</td></tr> <tr><td>相关指令</td> <td>IUP[ ]</td></tr></table> <p>对指定点的位置进行插值以保留它们与参考点 rp<sup>1</sup> 和 <sup>rp2</sup> 的原始关系。</p> <p>从堆栈中弹出点编号 p<sup>1</sup>、p<sup>2</sup>、...、ploopvalue。 移动每个点 pi，使其与 rp<sup>1</sup> 和 rp<sup>2</sup> 的关系与原始无指令轮廓中的关系相同。 即，以下关系成立：
<img src="data:image/gif;base64,R0lGODdhrgAoAIAAAP///wAAACwAAAAArgAoAAAC/4SPqcvtD6OctNqLs947hPNxSiiW5omGJAqs7AvHo+GetYznmqciXsv4CT83mu6IrPSAPmLQ2YLOktTqlOlaXo3MrfWL1K5I2i7XTD7y1jzwkw1vQ4jO8TmRvf/u7r6MrrcXZZQlCHLol5hUhlhThGUh+JgxSSH5UtnAOHjzuBlRxtZRErrGkfmW97ZgevEpggrKZ6OIITcmhUcnpLmzh2vWxJmLV6vEVRgMUkeMONI6xcjLCjXt9RyXrb2dPddYrKwnPiuRFvyqWqRqzHpmh+wT726Obfg9DunsTvPO7s37Tp28dbFmABwYBNwSev4eAEIjqQcuR/qO/WpCRqIuipzkJmjDyM2eK3LSeoXbQXKWwI4NZSmzVnFZs1EvZ3aSB4qhiYKa5MTkN4mnR58siUaB6VKopZZMaSr12DSqpYvLTg7hZFKq1oT5qqqrNvPkVqnm0nG9d22sVjE4b7Y9q3YsoFxsK5b6GTfqw4ntCgVkmVeuyk1BxQYWHM6myaeH2UHjtypa48kOIxmljDmz5s2cO3v+DDq06NGKCgAAOw==" alt="function5-1"></p> <p>如果 rp<sup>1</sup> 和 rp<sup>2</sup> 在投影向量上占据相同的位置，则该指令是非法的。</p> <p>更直观地说，IP[] 指令保留了一个点相对于两个参考点的相对关系。</p> <p>在下图中，点 p 是相对于参考点 rp<sup>1</sup> 和 rp<sup>2</sup> 进行插值的。 第一张图中，IP[]指令执行前的情况，p点到rp<sup>1</sup>原位置的距离为d1，p点到rp<sup>2</sup>原位置的距离为d2。 两个距离之比为 d1:d2。</p> <p><img src="data:image/gif;base64,R0lGODdhggEIAYAAAP///wAAACwAAAAAggEIAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wsczBhALCxMXGwMjKy8zNzcixwAbTudIE2NmwzwnJ0rbe2t3S1e/RxePkvOnS6L3V77Dq++Pg9bjwkObg8hf48erR8+V/t8bbs28NW2g7sAcmN4Sh8DgA6/HfCnyppGhv8UfxVUaEAjOwToIN7CCHLkNIobeZ2jtVEkQpP0DtIkKOFmK5Qhq02oyIonSWhAUyVMp3OUUHtFQy3lN7LUU6ghm2o6SvXaJptYs4pa2dXr17BinU4tC0qeVbQO1hZC6ZbtgriAzsqtkLRu3rsY6Oaxy7fvW7KBM+ytQ7jwBr9jdAJW3OFwmYqPIX9gLKbkR8tbwZbk3Aku6EwSFUgePdjmRNQrMF/BB/Q0a8NmlhZ1PRtv48Smc5+Q7aRyA9y+f3bhXVwG8CPCk9MgHqS58xrQb7BcPt0GdhzhkC+unr33ks0ppIenYt7wy/OZ16PAuJ29knXgBd6WHzk67PpzsfL/Zx/fb/6FAFiA+EVlHVkGPgTcf+ct6AFy0KXn4IPPeacehAcuVoJV6V3w4YYEVngRZRhmKKIOJF40UwtTrZhiPx1WpSFCpimoAYzJ6RhiBN3xNqGOMVJAXofCFVOdkEPax6IKrsmUo5JL3siRlD3pdiWHUxoHYkJWPoTlgl+iJtuJI2CGZGRjjhZXjyIEycGaoHlopoBa0rZlTibWuAOfeT5wXRZ1/gnoUAzKSagVmvnZWqJ9lmYEpDAgelc3lEapmnKXeiWpEDxt2uSW/oCK11GMEjmlmy8UOMOpaA06KZDPsdnpTGhSh52reupqEEtUEsdrW3WuqA9cYBVmUjJu/yKqKqgLkbrTbbCG+t602mlVKUkdjShgsKtiK9ei3Z1JgqqrFglmVXwtaiiBI3r725X0HbuujdReVt+n8b4pb5Y0Iittud81paSfMq2UW7LQ/irjviDExGDCviaYV5p2kptdsdrhiKAJMC58YGXjlufoDw5J11J5IJc8V4kBWkwyy49a267HMs88482DrKwzFDz3DHTIQes19B8/F53E0Ugzp/TSRTTt9BBQR60f1X9ZjXXWWm/NddeXeR3H1GBvPPYbYpfd6tlox0Dz2k0gqbbbKpcoNxkdxV03xizCm3cOz/rb9xZw3xu4Fm0XHhziduOtuMCNYwEp44/zO/kXfM1Xzh3m6CmsuRRQdq4o4HSD/rboo5M+X1ITo+6pBZmy3gNjz0oOe6Hq1u4z4bgnvdDuUbxjru9+0y68QMX/fnzynhCvfMvNM8H88zVLT70j0Vd/efXuas8c994rcj314Us//vPlf4++D+imT3HE7OOc7vt+q3v+7ggjLP/wh+avIvDB8w/AAEricALUUv2E97kCtsp0CjzXARHYwMxFcIIUrKAFL4jBDGpwgxzsoAc/CMIQinCEJCyhCU+IwhSqcIUsbKELXwjDGMqwFQUAADs=" alt="F025_instr7"></p> <p>IP[] 指令的效果如下图所示。 它沿着自由向量移动点 p，直到从 rp<sup>1</sup> 的当前位置到点 p 的距离 d3 与从点 p 到点 rp<sup>2</sup> 的当前位置的距离 d4 之比等于 d1:d2。 也就是说，点 p 沿着自由向量移动，直到 d1:d2 = d3:d4。当这些距离沿着投影向量测量时。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr8"></p> <h3 id="isect-将点-p-移动到两条线的-intersection"><a href="#isect-将点-p-移动到两条线的-intersection" class="header-anchor">#</a> ISECT[] 将点 p 移动到两条线的 InterSECTion</h3> <table><tr><td>代码范围</td> <td>0x0F</td></tr> <tr><td rowspan="5">Pops</td> <td>a0：A线的起点（uint32）</td></tr> <tr><td>a1：A线的终点（uint32）</td></tr> <tr><td>b0：B线的起点（uint32）</td></tr> <tr><td>b1：B线的终点（uint32）</td></tr> <tr><td>p：要移动的点 (uint32) 推动 -</td></tr> <tr><td>相关指令</td> <td>zp<sup>2</sup> with point p, zp<sup>0</sup> with line A, zp<sup>1</sup> with line B</td></tr></table> <p>将指定的点移动到指定的两条线的交点。</p> <p>弹出 A 行的端点 a<sup>0</sup> 和 a<sup>1</sup>，然后是 B 行的端点 b<sup>0</sup> 和 b<sup>1</sup>，然后是点 p。 将点 p 置于直线 A 和 B 的交点处。点 a<sup>0</sup> 和 a<sup>1</sup> 定义直线 A。类似地，b<sup>0</sup> 和 b<sup>1</sup> 定义直线 B。ISECT 忽略移动点 p 中的自由向量。</p> <p>在平行线 A 和 B 的退化情况下，该点位于中间。 那是。</p> <p><img src="data:image/gif;base64,R0lGODdhuAAiAIAAAP///wAAACwAAAAAuAAiAAAC/4SPqcvtD6OctNqLs968+88FoCUuJRCkVal6LXQmZxqPSm1H+HzgTezLBE23njFXRE52RAnvM2wifFGoTFSdMlRZlFZ6lE1fSxP5AdwqvwYWhdp2sufhufvd7HrrfOVzD0OTFqfTB9gjKEZ4iJYYpvdHt/ak13dXuGiY+aj5k8TouQk6acRVJmY6esQkCkcIlMU6qAYa6ad1doHFEnWJSCPXRubrNNzb6rgmilgqhLu8MXSH5Rxnq4yZdI3HVnma15l96I29PJ37jZJqE3RO3t3yXv7jJi9cP29mLWRqf0OdL6DAgSQANgJGMKHCEcT4CXoIMaLEiRQrWryIMaPGjE6fujxcCDIkhoYiS5oMccbgyXIIVyLx53JFuJgj0dF8eXNkEZg5ufX8CZQn0KHYhBI9msMo0qUuZjJ96icZ1KlUq1q9ijWr1q1cu3q1UAAAOw==" alt="function5-2"></p> <p>在下图中，点 p 从其当前位置移动到 a<sup>0</sup>、a<sup>1</sup> 定义的直线与 b<sup>0</sup>、b<sup>1</sup> 定义的直线的交点。 请注意，点 p 不需要沿着自由向量移动，而只是简单地重新定位在交点处。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr9"></p> <h3 id="iup-a-通过轮廓插值未触及的点"><a href="#iup-a-通过轮廓插值未触及的点" class="header-anchor">#</a> IUP[a] 通过轮廓插值未触及的点</h3> <table><tr><td>代码范围</td> <td>0x30 - 0x31</td></tr> <tr><td rowspan="2">a</td> <td>0：在y方向插值</td></tr> <tr><td>1：在x方向插值</td></tr> <tr><td>Pops</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp<sup>2</sup></td></tr> <tr><td>相关指令</td> <td>IP[ ]</td></tr></table> <p>在 zp<sup>2</sup> 引用的区域中插入未接触点，以保留未接触点与该区域中其他点的原始关系。</p> <p>逐个轮廓考虑参考字形轮廓轮廓，移动按顺序落在一对触摸点之间的任何未触摸点。 然而，这样一个点如何移动取决于它的投影是否落在触摸点的投影之间。 也就是说，如果未触摸点的投影 x 坐标或 y 坐标（取决于插值是在 x 中还是在 y 中）最初位于触摸对的坐标之间，则该坐标将在新坐标之间线性插值 接触点。 否则，未触摸点将移动最近触摸点从其原始轮廓位置移动的量。 布尔值 a 决定插值是在 x 方向还是在 y 方向。 自由度和投影矢量的当前设置不相关。</p> <p>下面的一组图说明了这种区别。 第一张图显示了执行 IUP[] 指令之前的轮廓。 这里 p<sup>1</sup>、p<sup>2</sup>、p<sup>3</sup>、p<sup>4</sup> 和 p<sup>5</sup> 是轮廓上的连续点。 点 p<sup>2</sup>、p<sup>3</sup> 和 p<sup>4</sup> 都依次落在轮廓上的 p<sup>1</sup> 和 p<sup>5</sup> 之间。 假设点 p<sup>3</sup> 已被触及。</p> <p><img src="data:image/gif;base64,R0lGODdhEgJeAYAAAP///wAAACwAAAAAEgJeAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8owEAY3n+s73/g882ILEovGITCpRw6XGBnVKp9SqlXEzZAHQ7fULDovHx6y3S3ZE0+y2+025nddwrb2Oz+vBTS06b7YnOEhY5MXVdegWWNjo+PgylwjYB2l5iclRiTi0uVijmCk6SvoQ+qZ4WrrKiqmK59kqO9v4CkiLmytoCxer+wscxhtMXGy8MnysvMz8VPvXHC0tk5zW5zudrS1STXbYvR0uHgEu9j2Ono5RLpwArQ4f7154bTYpj4/OLvwOSpcPsNk+PndM3QuIMNjAK9ggJFqYMKIeiFUoCuln5KDEjf8hLEppmOEhx5H0CHk0iJGkSm+DQI4QqePfypkVTiqxuS5lC0Y0e0rAWQboE43ICvo82kAoEZfUiJbgiTTqvIlJnIKQKTWrUiBMfcD8cC6r1K0/yLL4GhKU2LGUvOmMg3XtSrM86NJAuwCjXbnL9uLoyodok01++RorPANxj4dzDGutA7iXO8WOD0N2NbUyUsouIvc6ozkq552i8IaeORpZ6qWeTwNczQS2IdmuZdF+art2z9sveQdprVud7460hgfHbM04V+XHHzHXlOt585Juo0ufvsvaL+DYp12/wN1594TfLZQve358m/Q/2S9W/3qM+8Xz4RPkZ9l+vPpY+Nf/9a/fFABmll+A+gTW14AGVnVfgguKoyAi0UT44FJfUPhfhdooGB4rGGr4nhUfZgjihCKOWFeJJla0TYcqllYRiiG+eAyAMtJHY41UuFjcjTkWJWA6Pv6YAn884nIkkS19NGRZSm730X5NPsmNE0nqMiWVV1mJz5VaorKEl1hm+eUG7pH5W5ke3oTmcmqWwl6bab45SnpiKiQnneQwGFGeepqCxJ3ECPpnkGVw5GeheQWFaKKK1pCRo6w9WktGc1FK3W+Szobpkhai1ml2mtJEaKhcfUqqqbe4udumej7nKp+qgoneZrGqydytVemqpXKlbjjrJ16J9WuwiXnF603G/2pHIrHJEjncs2EuK1+zaxVLLWk7SMtlthduy22Yqljl7bbmaoZtuSfclq4+b6k751+h1TNZuN3R1u44YQlhFLzn3nXavnfYO51s+epLIBf9+puDwQHT6w/DwyZG8K5y6HXRwRInRXFlWIWyRcXBrSbybPvEtXFnTfGFck0pHxtDyawOJfO83LyrMTMtvzwtDDWD+/OPQqF88Vg588zES/2aNtfRSCddpcKQ8ttq0L0qLbUfaqFm9ZdDE6ZA1yrs/DRDWEuIttYjkV222VFTPRjbwjndtrbrZmyP2FfRXbfduKHUJd99+93bMIKbpLeivMmtDOODNxhT4uQc/rjK9P9J3h/mlOZKOT+aYypd5wx93ul1jtcpeuUxMzom6aaed7ojsau+HpsEz0577eKSgnvuuoubbOq+N7zjrb0P/zuTkh6PfPICCj829M0TfyGazE8vbPVNXo999giyIX33/3ouX/jixwS++TWpfz716cfoet3bs595+7NkSX/E9t8PS/757z++z3AufrTLE/S4B0BR7QGBHWBgAhdID5L974ETQxxnJkjBCkawMA7MoAJlZ5cOevCDINyKCEdIQucA5YQoTKEKPcLCFroQEjzCoAxRVRruxPCGM7zE6XbIwx66wnA2DKIh7neNehlRIEhiDBCXaBLrbA2KTGziFKnYl+j/hA2LVezRFblYIC+mDYw6ah0BsXhGMkLJOk9UI1XcWLY0wrE42yniHJ2EpYXdUYt5zNoe18hHOS7Ram38o/foeBFD8nGRelQknMroyNyEMZKrwJwgb3hJSvpQk/DKJCfF80lveTKUmSKlsUZpSiH+iUPfupSIWvnKWMqSJKx02ywNdbdcqiSEujQBXXjZSxL8skhQK5IdYRbMt/mymMtMpjKFSUxnCpNpMGLm2ZqJzWxCU5pbsuY1Y+NEzzlxnOQspznPic50qnOd7GynO98Jz3jKc570rKc974nPc1Yymn/jJlj42c+AbtOfHuAgNZFDUOh485kDFeg3HwpR4qim/5Cw3FFFLXpLXBqTkRrFaEa7BKpUnlKkVjwmkEjKv9uhVIz7XGkr5PBSl3oIKnWSaahQaVPn5XSVO91cTx+F05+aQ6iFCipRL3pUryWVTkZdqkedejWoKlWqUaXqk5pqVVlldatc7apXvwrWsIp1rGQtq1nPita0qnWtbG2rW98K17jKda50ratd74rXvOp1r3ztq1//CtjACnawhC2sYQ+L2MQqdrGMbaxjHwvZyEp2spStrGUvi9nManaznO2sZz8L2tCKdrSkLa1pT4va1Kp2taxtrWtfC9vYyna2tK2tbW+L29zqdre87a1vfwvc4Ap3uMQtrnGPi9zkKne5zEBtrnOfC93oSne61K2uda+L3exqd7vc7a53vwve8Ip3vOQtr3nPi970qne97G2ve98L3/jKd770ra9974vfuBYAADs=" alt="F025_instr10"></p> <p>点 p<sub>4</sub> 的 x 坐标介于 p<sub>1</sub> 和 p<sub>5</sub> 之间，而点 p<sub>2</sub> 和 p<sub>3</sub> 则没有。 假设 p<sub>1</sub> 和 p<sub>5</sub> 已被先前的指令移动，并且点 p<sub>3</sub> 已被触摸但未从其原始位置移动。 作为 IUP[1] 的结果，发生了 x 方向的插值。 点 p<sub>4</sub> 将被线性插值。 点 p<sub>2</sub> 将移动最近触摸点移动的量。 点 p<sub>3</sub> 将不受影响。 （假设点 p<sub>2</sub> 和 p<sub>4</sub> 处于它们的原始位置。这不是严格必要的，因为 UTP[ ] 指令可以不触及已移动的点，因此受 IUP[ ] 指令的操作影响。）</p> <p>作为 IUP[1] 指令的结果，移动了两个点。 第一步是下图所示的转变。 点 p<sub>1</sub> 从其原始位置平行于 x 轴移动了 ds 个单位的距离。 点 p<sub>2</sub> 平行于 x 轴移动，直到它与原始位置的距离等于 ds。</p> <p><img src="data:image/gif;base64,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2a0gAOvbjgV3fwMbLpRwO1nOGhe5m/9VrlFnu9zaSve5r61udH8p29Rqd7vXxS5Yo1pV6+Y2vKR5J2ZAUdTx4lSttC1pds5r3qc40zYjoa97T0ve1kKXvbqNp2VrGqb5+jenoV3vRHg34P02t7/tZXB15tcZzppvwsLsp+ooPOEEc1fD4m2wgkfEHnZieMQkLrGJT4ziFKt4xSxusYtfDOMYr9iuzvXwh/F7Y/1u2MY7Bu+bpJksBxc4x+rtMX+JbJjp8tiNBd2UN+P75CWMqnBbDNWUIwPl1KC3Rlnubo++GmUyTvUxYNZyawzUxLB9qslAeR2gKCLlMQcGzZmSKVNrI+cz5XmH5b0zUffs5dieCJuOgia7cAXKZfgGurGJjvOiM9voMD9a0KzDDF67e+hJO1rTxMg0p/H8ab2FWtSjPlypIXdqfKVaXKsGXatfDetYy3rWtK61rW+N61zrete87rWvfw3sYAt72MQutrGPjexkK3vZzG62s58N7WhLe9rUrra1r43tbGt729zutre/De5wi3vc5C63uc+N7nSre93sbre73w3veMt73vSut73vje9863vf/O63v/8N8IALfOAEL7jBD47whCt84bYtAAA7" alt="F025_instr11"></p> <p>第二步是下图所示的线性插值。 点 p4 沿指定轴移动到一个新位置，该位置保持与点 p<sub>1</sub> 和 p<sub>5</sub> 的相对距离。 插值后点p<sub>4</sub>到p<sub>1</sub>的原始距离(d<sub>1</sub>)与点p<sub>4</sub>到p<sub>5</sub>的原始距离(d<sub>2</sub>)之比等于点p<sub>4</sub>到p<sub>1</sub>(d<sub>3</sub>)的新距离与新点p<sub>4</sub>到p<sub>1</sub>的新距离(d<sub>3</sub>)之比。 点 p<sub>4</sub> 到 p<sub>4</sub> 的距离 (d<sub>4</sub>)。 即：d<sub>1</sub>:d<sub>2</sub> = d<sub>3</sub>:d<sub>4</sub></p> <p><img src="data:image/gif;base64,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" alt="F025_instr12"></p> <p>该指令对 zp2 指向的字形区域中的点进行操作。 该区域应始终为区域 1。将 IUP[ ] 应用于区域 0 是非法的。</p> <p>IUP[ ] 指令不接触它移动的点。 因此，受 IUP[ ] 指令影响的未触及点将受到后续 IUP[] 指令的影响，除非它们被中间指令触及。</p> <h3 id="jmpr-jump-相对"><a href="#jmpr-jump-相对" class="header-anchor">#</a> JMPR[] JuMP 相对</h3> <table><tr><td>代码范围</td> <td>0x1C</td></tr> <tr><td>Pops</td> <td>偏移量：要移动指令指针的字节数 (int32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>JROF[ ], JROT[ ]</td></tr></table> <p>将指令指针移动到由从堆栈中弹出的偏移量指定的新位置。
从堆栈弹出一个整数偏移量。 带符号的偏移量被添加到指令指针，并在指令流中的新位置恢复执行。 跳转是相对于指令本身的位置。 也就是说，+1 的偏移量会导致紧跟在 JMPR[] 指令之后的指令被执行。</p> <h3 id="jrof-相对跳转设置为假"><a href="#jrof-相对跳转设置为假" class="header-anchor">#</a> JROF[] 相对跳转设置为假</h3> <table><tr><td>代码范围</td> <td>0x79</td></tr> <tr><td>Pops</td> <td>e：堆栈元素偏移量：要移动指令指针的字节数（int32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>JMPR[ ] JROT[ ]</td></tr></table> <p>如果测试的元素具有 FALSE（零）值，则将指令指针移动到由从堆栈弹出的偏移量指定的新位置。</p> <p>弹出一个布尔值 e 和一个偏移量。 在布尔值 e 为 FALSE 的情况下，带符号的偏移量将添加到指令指针，并在新位置恢复执行； 否则，不进行跳跃。 跳转是相对于指令本身的位置。</p> <h3 id="jrot-相对跳转设置为-true"><a href="#jrot-相对跳转设置为-true" class="header-anchor">#</a> JROT[] 相对跳转设置为 True</h3> <table><tr><td>代码范围</td> <td>0x78</td></tr> <tr><td rowspan="3">Pops</td> <td>e：堆栈元素</td></tr> <tr><td>偏移量：要移动的字节数</td></tr> <tr><td>指令指针（int32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>JMPR[ ] JROF[ ]</td></tr></table> <p>如果测试的元素具有 TRUE 值，则将指令指针移动到由从堆栈弹出的偏移值指定的新位置。
弹出一个布尔值 e 和一个偏移量。 如果布尔值为 TRUE（非零），则带符号的偏移量将添加到指令指针，并且将在获得的地址处恢复执行。 否则，不会进行跳跃。 跳转是相对于指令本身的位置。</p> <h3 id="loopcall-循环调用函数"><a href="#loopcall-循环调用函数" class="header-anchor">#</a> LOOPCALL[] 循环调用函数</h3> <table><tr><td>代码范围</td> <td>0x2A</td></tr> <tr><td>Pops</td> <td>f：0 到 (n-1) 范围内的函数编号整数，其中 n 在“maxp”表中指定
count：调用函数的次数（有符号字）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>相关指令</td> <td>SLOOP[ ]</td></tr></table> <p>反复调用一个函数。</p> <p>弹出一个函数编号 f 和一个计数。 调用函数 f，计算次数。</p> <h3 id="lt-小于"><a href="#lt-小于" class="header-anchor">#</a> LT[] 小于</h3> <table><tr><td>代码范围</td> <td>0x50</td></tr> <tr><td rowspan="2">Pops</td> <td>e2：堆栈元素（StkElt）</td></tr> <tr><td>e1：堆栈元素（StkElt）</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>相关指令</td> <td>GT[ ], LTEQ[ ]</td></tr></table> <p>比较堆栈顶部的两个数字。 如果两个数字中的第二个小于第一个，则测试成功。</p> <p>从堆栈中弹出两个整数 e2 和 e1，并比较它们。 如果 e1 小于 e2，则将表示 TRUE 的 1 压入堆栈。 如果 e1 不小于 e2，则将表示 FALSE 的 0 放入堆栈。</p> <h3 id="lteq-小于或等于"><a href="#lteq-小于或等于" class="header-anchor">#</a> LTEQ[] 小于或等于</h3> <table><tr><td>代码范围</td> <td>0x51</td></tr> <tr><td rowspan="2">Pops</td> <td>e2：堆栈元素</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>b：布尔值（[0,1]范围内的uint32）</td></tr> <tr><td>相关指令</td> <td>GTEQ[ ], LT[ ]</td></tr></table> <p>比较堆栈顶部的两个数字。 如果两个数字中的第二个小于或等于第一个，则测试成功。
从堆栈中弹出两个整数 e2 和 e1 并比较它们。 如果 e1 小于或等于 e2，则表示 TRUE 的 1 被压入堆栈。 如果 e1 大于 e2，则将零（表示 FALSE）放入堆栈。</p> <h3 id="max-栈顶两个元素的最大值"><a href="#max-栈顶两个元素的最大值" class="header-anchor">#</a> MAX[] 栈顶两个元素的最大值</h3> <table><tr><td>代码范围</td> <td>0x8B</td></tr> <tr><td rowspan="2">Pops</td> <td>e2：堆栈元素</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>e1 和 e2 的最大值</td></tr> <tr><td>相关指令</td> <td>MIN[ ]</td></tr></table> <p>返回栈顶两个元素中较大的一个。</p> <p>从堆栈中弹出两个元素 e2 和 e1，并将这两个量中较大的一个压入堆栈。</p> <h3 id="md-a-测量距离"><a href="#md-a-测量距离" class="header-anchor">#</a> MD[a] 测量距离</h3> <table><tr><td>代码范围</td> <td>0x49 - 0x4A</td></tr> <tr><td rowspan="2">a</td> <td>0：测量网格拟合轮廓中的距离</td></tr> <tr><td>1：测量原始轮廓中的距离</td></tr> <tr><td>Pops 弹出</td> <td>p2：点编号 (uint32) p1：点编号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>d：距离（F26Dot6）</td></tr></table> <p>将 zp0 与点 p1、zp1 与点 p2、投影向量、双投影向量一起使用
测量指定的两点之间的距离。</p> <p>弹出两个点编号 p2 和 p1 并测量指定的两个点之间的距离。 距离 d 作为像素坐标被推入堆栈。 距离是有符号的。 颠倒列出点的顺序将改变结果的符号。</p> <p>根据布尔变量 a 的设置，将在原始轮廓或网格拟合轮廓中测量距离。 MD[0] 测量原始轮廓中的距离，而 MD[1] 测量网格拟合轮廓中的距离。 与往常一样，距离是沿着投影矢量测量的。 正如颠倒点的排列顺序会改变距离的符号一样，颠倒投影矢量的方向也会产生同样的效果。</p> <p>在下面的示例中，MD[1] 将产生从点 p1 到点 p2 的原始轮廓距离。 MD[0] 将产生从点 p1 到点 p2 的距离。</p> <p><img src="data:image/gif;base64,R0lGODdhtgGOAYAAAP///wAAACwAAAAAtgGOAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV1tfY2drb3N3e3tEhAe/k1ebn4eLY5+HWDQvk79/g6fLD5+IE9fP38PoK6PbJ47fACJ2fMn0B9BdwkL3mqXMGKDhg5l/UvQr58Civ8VW2lkYI+jwo4WRYIE+ZHkqpQQTKp0xTJCzJceXT6wSRMVTgc7c/r8qacnUFwzh+aSJ9SoRRJJlU4qmgGqU0wHQTSd2kjjVZ5YPwncOhFsV0QZRYgde+hiiLNo07JdILVtpLdw5VLNZ/dhXl1x97Ki6/cY4MB0BrcknNXwTcWI2fS12vhNSIxV4TKWGflOyJRqWzzObGYzP4g0LoNuolY0QtMWWJ9Wgnd1ZRyfX2uJrdp2qNiyXev+o47z790Yiw/3ahyf76jLjw+h2BxDdOc/OgOZTj1Q7eyXsHP34/27kPAStovHQr78+TTmVbRfTyU9Zvih6e+Wb18O/vxw9nP/5S/GeygICGBaBXLi34FqEKjgIAk2yAKDJUgIIREP1lXhFhdulKGGGyLwYYcTikhJiCRyQeGJeJg4kIpVsDiSi46kKGNhNc4I441T5Khjaz7w2CMFNK4FZJDq9VCkkYchqSRqSTaJxJNQGiHllBZWaeV4P2bpIJZcVveldmECMuSYJ8DoZZZoQjjZeFeV+QGcZk7UYgVrznkmaaShJFqa9FlHm3KL9SnnnLzZMM5XCIW1WZ14tjbbSOSNxlClIA5aWaFB5tbipHviBRGgyiXa2Z3fcbraohF+BWpLF0Ua4w5+NnNQn5cuNMKeqrZ6KGUNaTrhrAHpylCbjrLGz62h/8a6kaiwvSYqqsnlqtCrxFoGrAzCDoOTsRialeitrlLIYrboOGsZOAQlO+haWyJmarLLMsqYqXuVe+xAJsFqVbnb7mKukPrGGipH/FIbZsAy5YPUtL569u9pEoLKLk/omhDxS+RqEO6nNh28QsYkpbjVPRc3m6DCkE5lcr/SDQwVyDDYa9RlJXdqscpPiAxTvS8z6yvPq2J1sp1vttuH0Kmw6m6cRQfKZM0Oc/CWzD/6W3NZLkv39Ls8KL20zo6CKHawUTuFXaldP6fkdFVZ/ewMhJbNTK9xBg03E3SPKm1O2WbkLXql9e23e73l7QR+to6tsXtzgz2146R+tPdKiP8PXrkXswEKOSgqd54D5wbTpHPmWVxONjZrRz5gIah/Ww1vgQs6cxkkrx4WO3UC3qy29VFdJugO7p5cuJWI9foEwguSWnG4uwUpsMuL6fD0R/SUfEWs8i6r7Qtb/0rBptMZ304zZT9UkuObxfhJQZe2zZMZd6w83zeAz/yVSxivqpDrpw6fNJlMUVJBXwrwZ6CzeU1rlMPUdRDoOqxV51M4s9rzYgBB13kNfgRjmqS+B50NdoNmcqPMB6sFQoshKYNd0s/AKvixp5EQCv+7zYIeVq0BAg1ldhIhlbDFwtqxR1y4Kc/zahiF7QVRW0vkEPFi5BIDtg88xTqeDw+oLH3/iUSK4mLeBX0RsJatq4BDQiLrrvZFYBgmhCecItnkNMOvvSp2GKPUDoEYIB5Zp4mFWeOuPhjFNNJwhWZ0QxyXlKoT6imQfMTV/QQJiUMeCZA4o9ca1sfFp0hQYLpimBtlw8GvYQ4mV1Rhq1BoSUSVkmNGLGQehBWcMV4LWzpwZf88UJRMbsKW80GlRPiELwXikk96SYK8dgcdSLYORe8jigDXNTVdOg5F4uuFJEGJtCJYT5qmuGYKo3QbZZ6rZOJk4ipb2bCuJIWb/eGacNSpPF6Wz3/n49YKHRjJVkIjjuxcET73KcJ+XueeKGukfiRYTm1uUKAAQyML75RQNX6I/6FU8o9WZpeNB1HUmKoknDYsKk8MIgqjI0zPwUI6IPk0ih7egVsTw7M43VzupdHhlEEt1xSULjNPG/XbF2+aK5JqD1wMAqrThNoRcpVTp89ZqVLYEtFPaqgDTmUZOQtF09zRK6rm2CIeFbEvIHL1XLS0X1b+U6yejrOZY43D+cTH1GUoUa1u3Wpc65bWtgqMDJSrKmjgitQDvjSvdE3q3EKZR28ZdR003eOjVAiGwD6WfNS86zdsaVnmLJYX3tSbXv3S2Sh9ljCZHehXT7RZjkWktEMdHjZvxFqHNim0jxwtddBUpDlOtoSy7eJuX2Ciwv52ZbVN7alGalxv0JYptv+tEGb9OK7knmO5vTztcN0nSsiU9bqL8dAbpeuQbb6Wu/ULZ2zFw8uqCVdN54yuI8mbxJw6Fr7xiedb6buj7+E3sltsLnxJuF78xsu/+7WUrAJcYN8KkW/glWkNkILgBPdObn6V8ILBUWELY7ClGdaw7yT3Ng93waMivgKJS2yFDqM4xSpecfdUK1kX15KyYj0vivtbYxnvz6sMtrGO75jDGP/YTTVu8JdWG+Ehh4ywPlYyMK3l5Pjyy8hqanKUc0blRyX5yiEjMJcxnGX2FvTLO/sumaXs5TNLTs1SaDGbr6SVN8OGc3K+npVXfOIt19mIJmzmngnaZz3/OZ6pHLSSaQ0sVUNDLa3vVbQCm+foQyM6zFXWaqQnmK5LB6Gvmm6qkDsN6lCLetSkLrWpT43qVKt61axutatfDetYy3rWtK61rW+N61zrete87rWvfw3sYAt72MQutrGPjexkK3vZzG62s58N7WhLe9rUrra1r43tbGt729zutre/De5wi3vc5C63uc+N7nSre93sbvcrCgAAOw==" alt="F025_instr13"></p> <h3 id="mdap-a-move-direct-absolute-point-直接移动绝对点"><a href="#mdap-a-move-direct-absolute-point-直接移动绝对点" class="header-anchor">#</a> MDAP[a] (Move Direct Absolute Point) 直接移动绝对点</h3> <table><tr><td>代码范围</td> <td>0x2E - 0x2F</td></tr> <tr><td rowspan="2">a</td> <td>0：不对值进行四舍五入</td></tr> <tr><td>1：对值进行四舍五入</td></tr> <tr><td>Pops 弹出</td> <td>p：点编号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>Sets 设置</td> <td>rp0 和 rp1 设置为点 p</td></tr> <tr><td>Uses 使用</td> <td>zp0，自由向量，投影向量，圆形状态</td></tr> <tr><td>相关指令</td> <td>MDRP[ ], MIAP[ ]</td></tr></table> <p>触发并在某些情况下舍入指定点。 “被打乱”的点将不受后续IUP[]指令的影响，并且通常旨在用作未来指令的参考点。 点按舍入设置为网格的点将导致该点沿投影向量具有整数值坐标。 如果投影矢量设置为 x 轴或 y 轴，这将导致点网格对齐。
弹出一个点编号 p，并将参考点 rp0 和 rp1 设置为点 p。 如果布尔值 a 设置为 1，则根据投影矢量测量的点 p 的坐标将被舍入，然后从其当前位置移动舍入距离。 如果布尔值 a 设置为 0，则点 p 不会移动，但仍被标记为沿当前自由向量指定的方向触发。</p> <h3 id="mdrp-abcde-move-direct-relative-point-移动径直相对点"><a href="#mdrp-abcde-move-direct-relative-point-移动径直相对点" class="header-anchor">#</a> MDRP[abcde](Move Direct Relative Point) 移动径直相对点</h3> <table><tr><td>代码范围</td> <td>0xC0 - 0xDF</td></tr> <tr><td rowspan="2">a</td> <td>0：不重置rp0到点p</td></tr> <tr><td>1：设置rp0为点p</td></tr> <tr><td rowspan="2">b</td> <td>0：不保持距离大于或等于最小距离</td></tr> <tr><td>1：保持距离大于或等于最小距离</td></tr> <tr><td rowspan="2">c</td> <td>0：不舍入距离</td></tr> <tr><td>1：四舍五入距离</td></tr> <tr><td>de</td> <td>引擎特性补偿的距离类型</td></tr> <tr><td>Pops 弹出</td> <td>p2：点数 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>Sets 设置</td> <td>p点移动后，rp1等于rp0，rp2等于点号p； 如果 a 标志设置为 TRUE，则 rp0 设置为等于点号 p</td></tr> <tr><td>Uses 使用</td> <td>d：距离（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>zp0 与 rp0 和 zp1 与点 p、最小距离、圆形状态、单宽度值、单宽度切入、自由向量、投影向量、双投影向量</td></tr> <tr><td>相关指令</td> <td>MDAP[ ], MIRP[ ]</td></tr></table> <p>保留指定点和参考点 rp0 之间的主轮廓距离。</p> <p>弹出一个点号p，并沿自由向量移动点p，使其新位置到rp0当前位置的距离与原始无指令轮廓中两点之间的距离相同，然后调整为 与布尔设置保持一致。 请注意，只有 rp0 和点 p 的原始位置以及 rp0 的当前位置决定了点 p 沿自由向量的新位置。</p> <p>MDRP[] 通常用于使用来自原始轮廓的值来控制字形特征的宽度或高度。 由于 MDRP[] 使用直接测量并且不引用控制值切入，因此它用于控制所指示的字形所特有的测量。 如果需要协调对点的控制与字体中其他字形中的点的处理，则需要 MIRP[] 指令。</p> <p>虽然MDRP[]不是指CVT，但其效果确实取决于单宽度切入值。 如果从无指令轮廓获取的测量值与单一宽度值之间的设备空间距离小于单一宽度切入，则将优先使用单一宽度值而不是轮廓距离。 换句话说，如果两个距离足够近（相差小于单一宽度切入），则将使用单一宽度值。</p> <p>round state图形状态变量的设置将决定点p到rp0的距离是否以及如何舍入。 如果未设置舍入位，则该值将不舍入。 如果设置了舍入位，则效果将取决于舍入状态的选择。</p> <p>MDRP[]指令也可以设置为使用最小距离值。 最小距离设置两点之间的距离可以舍入到的值的下限。</p> <p>与所有 TrueType 距离一样，使用 MDRP[] 指令测量的距离必须是黑色、白色或灰色。 用布尔值表示该值允许解释器根据需要补偿发动机特性。</p> <p>如下图所示，点 p 沿着自由向量从当前位置移动到距参考点 rp0 距离为 d 的新位置。 这个距离与p到rp0的原始距离相同。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr14"></p> <h3 id="miap-a-移动间接绝对点"><a href="#miap-a-移动间接绝对点" class="header-anchor">#</a> MIAP[a] 移动间接绝对点</h3> <table><tr><td>代码范围</td> <td>0x3E - 0x3F</td></tr> <tr><td rowspan="2">a</td> <td>0：不舍入距离，不看控制值切入</td></tr> <tr><td>1：圆整距离，看控制值切入</td></tr> <tr><td rowspan="2">Pops 弹出</td> <td>n：CVT 条目号 (F26Dot6)</td></tr> <tr><td>p：点编号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>Sets 设置</td> <td>将 rp0 和 rp1 设置为点 p</td></tr> <tr><td>Uses 使用</td> <td>zp0、圆形状态、控制值切入、自由向量、投影向量</td></tr> <tr><td>相关指令</td> <td>MSIRP[ ], MIRP[ ], MDAP[ ]</td></tr></table> <p>通过将点移动到控制值表中指定的位置，可以将点的位置与其他相似点的位置进行协调。</p> <p>弹出CVT条目号n和点号p，然后将点p移动到第n个控制值表条目指定的绝对坐标位置。 坐标是沿着当前投影矢量测量的。 如果布尔值 a 的值为 1，则位置将按照舍入状态指定进行舍入。 如果布尔值a的值为1并且CVT值与原始位置之间的设备空间差大于控制值切入，则原始位置将被四舍五入（而不是CVT值）。</p> <p>上面的布尔值控制舍入和控制值切入的使用。 要让该布尔值仅指定 MIAP[] 指令是否应查看控制值切入值，请使用 ROFF[] 指令关闭舍入。</p> <p>该指令可用于“创建”阴影区点。 这是通过将 zp0 设置为区域 0 并将最初位于原点的指定点移动到所需位置来完成的。</p> <p>在下图中，点 p 沿着自由向量移动，直到它占据沿着投影向量投影到 c 个单位的位置。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr15"></p> <h3 id="min-栈顶两个元素的最小值"><a href="#min-栈顶两个元素的最小值" class="header-anchor">#</a> MIN[] 栈顶两个元素的最小值</h3> <table><tr><td>代码范围</td> <td>0x8C</td></tr> <tr><td>Pops 弹出</td> <td>e2：堆栈元素 e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>e1 和 e2 中的最小值</td></tr> <tr><td>相关指令</td> <td>MAX[ ]</td></tr></table> <p>返回顶部两个堆栈元素中的最小值。</p> <h3 id="mindex-将-indexed-元素移动到栈顶"><a href="#mindex-将-indexed-元素移动到栈顶" class="header-anchor">#</a> MINDEX[] 将 INDEXed 元素移动到栈顶</h3> <table><tr><td>代码范围</td> <td>0x26</td></tr> <tr><td>Pops 弹出</td> <td>k：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>ek：堆栈元素</td></tr> <tr><td rowspan="5">堆栈之前</td> <td>k：堆栈元素编号（uint32）</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>...</td></tr> <tr><td>ek-1：堆栈元素</td></tr> <tr><td>ek：栈元素</td></tr> <tr><td rowspan="4">堆栈之后</td> <td>ek：索引元素</td></tr> <tr><td>e1：堆栈元素</td></tr> <tr><td>...</td></tr> <tr><td>ek-1：堆栈元素</td></tr> <tr><td>相关指令</td> <td>CINDEX[ ]</td></tr></table> <p>将索引元素移动到堆栈顶部，从而将其从原始位置删除。</p> <p>从堆栈中弹出一个整数 k，并将索引为 k 的元素移动到堆栈顶部。</p> <h3 id="mirp-abcde-移动间接相对点"><a href="#mirp-abcde-移动间接相对点" class="header-anchor">#</a> MIRP[abcde] 移动间接相对点</h3> <table><tr><td>代码范围</td> <td>0xE0 - 0xFF</td></tr> <tr><td rowspan="2">a</td> <td>0：不将rp0设置为p</td></tr> <tr><td>1：设置rp0为p</td></tr> <tr><td rowspan="2">b</td> <td>0：不保持距离大于或等于最小距离</td></tr> <tr><td>1：保持距离大于或等于最小距离</td></tr> <tr><td rowspan="2">c</td> <td>0：不舍入距离，不看控制值切入</td></tr> <tr><td>1：圆整距离，看控制值切入值</td></tr> <tr><td>de：</td> <td>引擎特性补偿的距离类型</td></tr> <tr><td>Pops 弹出</td> <td>n：CVT 条目号 (F26Dot6) p：点号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>Uses 使用</td> <td>zp0 与 rp0 和 zp1 与点 p。 圆形状态、控制值切入、单宽度值、单宽度切入、自由向量、投影向量、自动翻转、双投影向量</td></tr> <tr><td>Sets 设置</td> <td>移动点后，该指令将 rp1 设置为等于 rp0，将 rp2 设置为等于点号 p； 最后，如果 a 的值为 TRUE，则 rp0 设置为点号 p。</td></tr> <tr><td>相关指令</td> <td>MSIRP[ ], MIAP[ ], MDRP[ ]</td></tr></table> <p>通过使某个点和参考点之间的距离受控制值表条目的约束，可以将该距离与其他类似距离进行协调。
沿着自由向量移动点 p，使得从 p 到 rp0 当前位置的距离等于引用的 CVT 条目中规定的距离，假设切入测试成功。 请注意，在进行切入测试时，MIRP[] 使用 p 和 rp0 之间的原始轮廓距离。 如果切入测试失败，点 p 将被移动，使其距 rp0 当前位置的距离等于 p 与 rp0 引用的点之间的原始轮廓距离。</p> <p>MIRP[] 指令可以根据许多条件保留两点之间的距离。 根据布尔标志b的设置，距离可以保持大于或等于由最小距离状态变量建立的值。 类似地，可以根据round state图形状态变量来设置指令对距离进行舍入。 最小距离变量的值是两点之间的距离可以舍入到的最小可能值。 另外，如果设置了 c 布尔值，则 MIRP[] 指令将根据控制值切入进行操作。 如果实际测量值与 CVT 中的值之间的差异足够小（小于切入值），则将使用 CVT 值而不是实际值。 如果CVT值和单宽度值之间的设备空间差小于单宽度切入，则使用单宽度值而不是控制值表距离。</p> <p>上面的 c 布尔值控制舍入和控制值表条目的使用。 如果您希望此布尔值的含义仅指定 MIRP[] 指令是否应查看控制值切入，请使用 ROFF[] 指令关闭舍入。 通过这种方式，可以指定舍入已关闭，但切入仍然适用。</p> <p>MIRP[] 可用于在阴影区域创建点。</p> <p>在下图中，点 p 沿着自由向量移动，直到其到点 rp0 的距离等于参考 CVT 条目中找到的距离 d。</p> <p><img src="data:image/gif;base64,R0lGODdhqAETAYAAAP///wAAACwAAAAAqAETAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV1tfY2drb3N3e39Da4QME4+Hn6Onq6uWW6+PhxgEA8w/w48j28fnE+vfy/vzt8+cfUE5irYL6FBX/wW9mrokFfAiLLKhZtIzB1GbP8Wj03cOK1jMoQKqZFzRpIkypPPPqpUJjJau5ceWWajWcwmxVsxd9Lq6bOiTnQgdQ1dh/Pn0XdJSRUF+JRp01Evly6cKgohUIpYQ5nb6jOqU6tB5bECW/ZAV3YsxQZ1mwno2rSd0M6lGxcuXlNo96Lq63eC3kOAA1e4G4is4QyI66gsvPjCYDwBIUdmjKjdZRSN5yjeDGKyZ82gU3ReE/N0acF9LK9mq/o1JNeyLdGuTek2bs5gpn7eDUO0k6e6ga+IjaTgTOM/kB/5Spq5D+FNZjqXznuLdexErjffzn0IdfHRS4YH4v0GeASPz2dezqC9e0LwLYyfz2Y9hvT4v+j/18BffwCSV14H9wkYQoADElScBAoieNiDktXznwgSQsgaDtZdqBaHGD7goYP1HfehDAd6MGKJXIS4wHYsqqjhi/SMKCOMNrCYYg012qhCjurtyCMJFeoAZJAfDJlAkUkqaSRjBTrAJHtNkggBTUg2EKVaU/YYQUo+QhlPlgBtmR2I+HwJolkaknkCXFdWqeWabJqQ1JtdjhnjnCWAZCcFX+m54pIdiQloclANdWKhYSBJKJ2KhgZYo3tKil2DVlAKnKVYYCqbplok2uRvaHBKl5egdkFqWhSKml+qb3lqhqs7sSqHrFedZKt70M3I66km6uTrG7TCE2axvRob7H5W/+XKBETgIAvtsZAye4Wzr0q7664dJltrfGpKp1m20f7ILQt8lmuQbtGKy6uQ2hoqzmVNDWvguvaaqRFi9FrYorxY7vsrtvnOeNeTPVKbk1YATxdmPw2zK+6GLRi82Jno0pDvfRviOm69FAcGK3ofV9nnmBB3vG3IUl08BZpHHrtxu6W2RcfCKOZ4ssDPIlpKySLqzG5NRbE8yMimAY0yLDZLYTRh9wYNG8LQED0a1Y9qt/TVaWS9otW4nev1E9bOqRzXvX1baLFhUzE2m2aX8fZ5TXuWtk1S93D3OSprTUbcfEfx5t5/A64wg3kPbtpjFh+OeOL/rt04vHjGGbmw7JvZXTkcZSuXueWXS9l5G8QxHjpnipcubOGopz736q6/Dnvsss9Oe+2234577rrvznvvvv8OfPDCD0988cYfj3zyyi/PfPPOPw999NJPT3311l+Pffbab899995/D3744o9Pfvnmn49++uqvz3777r8Pf/zyz09//fbfj3/++u/Pf//+/w/AAApwgAQsoAEPiMAEKnCBDGygA7NQAAA7" alt="F025_instr16"></p> <h3 id="mppem-measure-pixels-per-em-测量每个-em-的像素"><a href="#mppem-measure-pixels-per-em-测量每个-em-的像素" class="header-anchor">#</a> MPPEM[] Measure Pixels Per EM 测量每个 EM 的像素</h3> <table><tr><td>代码范围</td> <td>0x4B</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>ppem：每 em 的像素 (Euint16)</td></tr> <tr><td>使用</td> <td>投影向量</td></tr> <tr><td>相关指令</td> <td>MPS[ ]</td></tr></table> <p>将当前每 em 的像素数推入堆栈。 每em的像素是渲染设备的分辨率以及当前点大小和当前变换矩阵的函数。 该指令查看投影向量并返回该方向上每 em 的像素数。 该数字始终是整数。</p> <p>下图分别显示了 18 点 Times New Roman 字体在 72 dpi、144 dpi 和 300 dpi 下的放大倍数。 增加每 em 的像素数可以提高所获得图像的质量。 但是，它不会改变所获得图像的绝对大小。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr17"></p> <h3 id="mps-measure-point-size-测量点大小"><a href="#mps-measure-point-size-测量点大小" class="header-anchor">#</a> MPS[] Measure Point Size 测量点大小</h3> <table><tr><td>代码范围</td> <td>0x4C</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>pointSize: 当前点大小(Euint16)</td></tr> <tr><td>相关指令</td> <td>MPPEM[ ]</td></tr></table> <p>将当前点值推入堆栈。</p> <p>测量点大小可用于获得一个值，该值用作选择是否分支到通过指令流的替代路径的基础。 它使得可以以不同的方式处理低于或高于某个阈值的点大小。</p> <p>下图显示了 72 dpi 下 12 点、24 点和 48 点 Times New Roman Q 的放大倍数。 请注意，增加字形的点大小会增加其绝对大小。 在低分辨率设备（例如屏幕）上，可以以更高的点大小捕获更多细节。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr18"></p> <h3 id="msirp-a-move-stack-indirect-relative-point-移动堆栈间接相对点"><a href="#msirp-a-move-stack-indirect-relative-point-移动堆栈间接相对点" class="header-anchor">#</a> MSIRP[a] Move Stack Indirect Relative Point 移动堆栈间接相对点</h3> <table><tr><td>代码范围</td> <td>0x3A - 0x3B</td></tr> <tr><td rowspan="2">a</td> <td>0：不改变rp0</td></tr> <tr><td>1：设置rp0为点号p</td></tr> <tr><td>Pops 弹出</td> <td>d: 距离 (F26Dot6) p: 点编号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>Uses 使用</td> <td>zp1 与点 p 和 zp0 与 rp0、自由向量、投影向量</td></tr> <tr><td>相关指令</td> <td>MIRP[ ]</td></tr></table> <p>通过设置从堆栈中弹出的值的距离，可以协调点和参考点之间的距离。</p> <p>弹出距离 d 和点编号 p，并使点 p 与 rp0 当前位置之间的距离等于 d。 距离 d 以像素坐标表示。</p> <p>MSIRP[ ] 与 MIRP[ ] 指令非常相似，只是从堆栈而不是 CVT 中获取距离。 由于MSIRP[]不使用CVT，因此控制值切入不是MIRP[]中的因素。 由于 MSIRP[ ] 不进行舍入，因此其效果不依赖于舍入状态。</p> <p>MSIRP[] 可用于在阴影区域创建点。</p> <p>在下图中，点 p 沿着自由向量移动，直到与 rp0 的距离为 d。</p> <p><img src="data:image/gif;base64,R0lGODdhxAEoAYAAAP///wAAACwAAAAAxAEoAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV1tfY2drb3N3e39DR4uPk5ebn6Onq6+zt7u/g4fLz9PX29/j5+vv8/f7/8PMKDAgQQLGjyIMKHChQwbOnwIsUeAABFtTZyoCKOKi/8PL1J8pNHEx48KOVaiGBLEyIQeN6Ek2WFlwZaiUmYwKZDmKYw2JcAEiPNVTwc/+emkxbNk0Fw8ixo4Og9qsJQeh7ZbeuxlVafppC7bylVbWABem4EVxxVrtLNNhVTNRFXttLcJXoolKxfb2Kd7v+YV25cvXhx/G9EdF3gB2MMoZEbSmfhaZAWLrZJwbBjr5GqWI5xlgTlR2cHkNlN+21ll6kCF0ZlWHLTtiNd4RrNb7TMt6Q+06dheuBr3pN8VISTF1Lo4BdmiTwtXfvMBcTckp+N7vtHuAY7Y0zCeKXEwSry9xST/Vx60xu5jWqavx/7FSO3UYzd8n2K8yfhXrB//5K8eeaeR1R6ABOHX2F/MZeEfQwju8CAPDToUIYT0LTEhdP3tRlhf52kYhoGzNZAhiCFeKJ9zFZrIBYorhPQhi5SpcVx2Mco44BoLilAijjPGUaF7K2ooYosuTrDUkETecSQDXikJHZRbWGablMUV+UR5TfXoIwZWDoHld12e8KVbBHqZZJljlhGaZ4XVuCZrH04IZ5x7wPSTTTc6OZ6dtSFQ1HxY1tWknyTWN6ibhiqKxlYw1LnodmYcpiaJha5ZqYSfnXlDokqB4ehTQECKY6Y1bCqqW336aGoMqALaakyxwuOpDq8qpsSOEc26gYdiWtrEpZGCZumv0klB6rD5/6m4p6RU6KpsCeuFKket0cJmbLWrBsTrBdT2kWw+3SL57bVaWMtbqFKOa66TFkK1bru2dlgWuoLJ2ym7txKLb6eulvtov/m2sO+/AttQKcAIH3wqn/gVjDC7DLvLqWewZpuDxBP/OJlWxGm8sUTdKUxxyGxy7CbGuJp8cl2pOqwyoRWzHKJzMOMUWZsN0xxgys2+DDKgPBMsHclI3pvx0D0TGjO5M0es9IsXc5lE0PgK+nOwVsc5FsRTRu2BVU2fC3bYTG99KtpjYl02IlS3ra29cE+639yCwKu2hHbDfOgcckeadRt5K/W3eYPPFHi1YL/tm9KJM3l4VNhGXgXl8f/g+TgfltM6dnNXF773iZmH3ijOm5MuMuiAnB7O6IbdZzR5rJcOXJ6Bui7J7MgMNa3qi/iOVliMc6J7MZi7XEvxxGAOo0XKC8O80Bb9J7Ozyf8n/POopw3b9prb7j24scuiffh6my8n+qypvzr7fwDv/obxf4/7/FOuZ78dbOfvN4Hb8v+G+TwNgGzYT/kIaCP4IZAJClygAx8IwQgSoXMSrKAFL4hBMFEwg1aQic44SLYz6QeEX/Cg/0joBUFZD4UpZOGkXAjDGMpwhjSsoQ1viMMc6nCHPOyhD38IxCAKcYhELKIRj4jEJCpxiUxsohOfCMUoSnGKVKyiFa+IxSwxanGLXOyiF78IxjCKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+Ixzzq8SAFAAA7" alt="F025_instr19"></p> <h3 id="mul-multiply-乘法"><a href="#mul-multiply-乘法" class="header-anchor">#</a> MUL[] MULtiply 乘法</h3> <table><tr><td>代码范围</td> <td>0x63</td></tr> <tr><td rowspan="2">Pops 弹出</td> <td>n2：乘数（F26Dot6</td></tr> <tr><td>n1：被乘数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>(n2 * n1)/64：乘积 (F26Dot6)</td></tr> <tr><td>相关指令</td> <td>DIV[ ]</td></tr></table> <p>将堆栈顶部的两个数字相乘。 从堆栈中弹出两个 26.6 数字 n2 和 n1，并将两个元素的乘积压入堆栈。 52.12 结果右移 6 位，并丢弃高 26 位，得到 26.6 结果。</p> <h3 id="neg-negate-否定门"><a href="#neg-negate-否定门" class="header-anchor">#</a> NEG[] NEGate 否定门</h3> <table><tr><td>代码范围</td> <td>0x65</td></tr> <tr><td>Pops 弹出</td> <td>n：像素坐标（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>-n：n1 的否定 (F26Dot6)</td></tr></table> <p>对堆栈顶部的数字求反。
从堆栈中弹出一个数字 n，并将 n 的负值压入堆栈。</p> <h3 id="neq-not-equal-不等于"><a href="#neq-not-equal-不等于" class="header-anchor">#</a> NEQ[] Not EQual 不等于</h3> <table><tr><td>代码范围</td> <td>0x63</td></tr> <tr><td rowspan="2">Pops 弹出</td> <td>n2：乘数（F26Dot6</td></tr> <tr><td>n1：被乘数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>(n2 * n1)/64：乘积 (F26Dot6)</td></tr> <tr><td>相关指令</td> <td>DIV[ ]</td></tr></table> <p>判断栈顶两个元素是否不相等。
从堆栈中弹出两个数字 e2 和 e1 并比较它们。 如果它们不同，则将表示 TRUE 的 1 压入堆栈。 如果它们相等，则为零，表示 FALSE 被压入堆栈。</p> <h3 id="not-logical-not-逻辑非"><a href="#not-logical-not-逻辑非" class="header-anchor">#</a> NOT[] logical NOT 逻辑非</h3> <table><tr><td>代码范围</td> <td>0x5C</td></tr> <tr><td>Pops 弹出</td> <td>e：栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>(not e)：e 的逻辑非 (uint32)</td></tr></table> <p>对堆栈顶部的数字取逻辑非。</p> <p>从堆栈中弹出数字 e，并返回对 e 执行逻辑 NOT 运算的结果。 如果 e 为零，则将 1 压入堆栈；如果 e 非零，则将 0 压入堆栈。</p> <h3 id="npushb-push-n-bytes-压入-n-个字节"><a href="#npushb-push-n-bytes-压入-n-个字节" class="header-anchor">#</a> NPUSHB[] PUSH N Bytes 压入 N 个字节</h3> <table><tr><td>代码范围</td> <td>0x40</td></tr> <tr><td rowspan="2">From IS</td> <td>n：要推送的字节数（1 个字节解释为整数）</td></tr> <tr><td>b1, b2,...bn：n 个字节的序列</td></tr> <tr><td>Pushes 压入栈</td> <td>b1、b2、...bn：n 个字节的序列，每个字节扩展为 32 位 (uint32)</td></tr> <tr><td>相关指令</td> <td>NPUSHW[ ], PUSHB[ ], PUSHW[]</td></tr></table> <p>从指令流中取出 n 个字节并将它们压入堆栈。</p> <p>查看指令流中的下一个字节 n，并从指令流中取出 n 个无符号字节，其中 n 是 (0 255) 范围内的无符号整数，并将它们推入堆栈。 要压入的字节数 n 不会压入堆栈。</p> <p>每个字节值在压入堆栈之前都会无符号扩展为 32 位。</p> <h3 id="npushw-push-n-words-压入n个字"><a href="#npushw-push-n-words-压入n个字" class="header-anchor">#</a> NPUSHW[] PUSH N Words 压入n个字</h3> <table><tr><td>代码范围</td> <td>0x41</td></tr> <tr><td rowspan="2">From IS</td> <td>n：要压入的字数（1 个字节代表整数）</td></tr> <tr><td>w1, w2,...wn：由字节对组成的 n 个字序列，高字节首先出现</td></tr> <tr><td>Pushes 压入栈</td> <td>w1、w2、...wn：n 个字的序列，每个字扩展为 32 位 (int32)</td></tr> <tr><td>相关指令</td> <td>NPUSHW[ ], PUSHB[ ]</td></tr></table> <p>从指令流中取出 n 个字并将它们压入堆栈。</p> <p>查看下一个指令流字节 n 并从指令流中取出 n 个 16 位有符号字，其中 n 是 (0 255) 范围内的无符号整数，并将它们压入堆栈。 每个字在放入堆栈之前都会被符号扩展为 32 位。值 n 不会被压入堆栈。</p> <h3 id="nround-ab-no-rounding-of-value-不对值进行舍入"><a href="#nround-ab-no-rounding-of-value-不对值进行舍入" class="header-anchor">#</a> NROUND[ab] No ROUNDing of value--不对值进行舍入</h3> <table><tr><td>代码范围</td> <td>0x6C - 0x6F</td></tr> <tr><td>ab</td> <td>引擎特性补偿的距离型</td></tr> <tr><td>Pops 弹出</td> <td>n1：像素坐标（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>n2：像素坐标（F26Dot6）</td></tr> <tr><td>相关说明</td> <td>ROUND[ ]</td></tr></table> <p>更改堆栈顶部数字的值以补偿引擎特性。</p> <p>从堆栈中弹出一个值 n1，并可能增加或减少其值以补偿使用布尔设置 ab 建立的引擎特性。 结果 n2 被压入堆栈。</p> <p>NROUND[ab] 因其与 ROUND[ab] 的关系而得名。 它执行与 ROUND[ab] 相同的操作，只是它不对补偿引擎特性后获得的结果进行舍入。</p> <h3 id="odd-odd"><a href="#odd-odd" class="header-anchor">#</a> ODD[] ODD</h3> <table><tr><td>代码范围</td> <td>0x6C - 0x6F</td></tr> <tr><td>Pops 弹出</td> <td>n1：像素坐标（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>n2：像素坐标（F26Dot6）</td></tr> <tr><td>使用</td> <td>四舍五入状态</td></tr> <tr><td>相关说明</td> <td>ROUND[ ]</td></tr></table> <p>测试栈顶的数字是否为奇数。</p> <p>从堆栈中弹出一个数字 e1，并在测试之前根据舍入状态的当前设置对其进行舍入。 然后该数字被截断为整数。 如果截断的数字是奇数，则将 1（表示 TRUE）压入堆栈；如果是偶数，则将 0（表示 FALSE）压入堆栈。</p> <h3 id="or-logical-or-逻辑或"><a href="#or-logical-or-逻辑或" class="header-anchor">#</a> OR[] logical OR--逻辑或</h3> <table><tr><td>代码范围</td> <td>0x5B</td></tr> <tr><td>Pops 弹出</td> <td>e2：堆栈元素 e1：堆栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>(e1 或 e2)：e1 和 e2 的逻辑或 (uint32)</td></tr> <tr><td>相关说明</td> <td>AND[ ]</td></tr></table> <p>取堆栈顶部两个数字的逻辑或。</p> <p>将两个数字 e2 和 e1 从堆栈中弹出，并将两个元素之间的逻辑或运算的结果压入堆栈。 如果两个元素都为 FALSE（值为零），则压入零。 如果两个元素之一都为 TRUE（具有非零值），则压入 1。</p> <h3 id="pop-pop-top-stack-element-pop-栈顶元素"><a href="#pop-pop-top-stack-element-pop-栈顶元素" class="header-anchor">#</a> POP[] POP top stack element--POP 栈顶元素</h3> <table><tr><td>代码范围</td> <td>0x21</td></tr> <tr><td>Pops 弹出</td> <td>e：栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr></table> <p>从堆栈中弹出顶部元素。</p> <h3 id="pushb-abc-push-bytes-push-字节"><a href="#pushb-abc-push-bytes-push-字节" class="header-anchor">#</a> PUSHB[abc] PUSH Bytes--PUSH 字节</h3> <table><tr><td>代码范围</td> <td>0xB0 - 0xB7</td></tr> <tr><td>abc</td> <td>要压入的字节数 - 1</td></tr> <tr><td>From IS</td> <td>b0、b1、bn：n + 1 个字节的序列，其中 n = 4a+2b+c = abc2</td></tr> <tr><td>Pushes 压入栈</td> <td>b0、b1、...、bn：n + 1 个字节的序列，每个字节扩展为 32 位 (uint32)</td></tr> <tr><td>相关指令</td> <td>NPUSHB[ ], PUSHW[ ], NPUSHB[]</td></tr></table> <p>从指令流中获取指定数量的字节并将它们推送到解释器堆栈上。</p> <p>变量a、b和c是表示从000到111（二进制为0-7）的数字的二进制数字。 值 1 会自动添加到 abc 数字中，以获得实际压入的字节数。</p> <p>当字节值被压入堆栈时，它们会用零进行无符号扩展以形成 32 位数字。</p> <h3 id="pushw-abc-push-words-压入字"><a href="#pushw-abc-push-words-压入字" class="header-anchor">#</a> PUSHW[abc] PUSH Words--压入字</h3> <table><tr><td>代码范围</td> <td>0xB8 - 0xBF</td></tr> <tr><td>abc</td> <td>要压入的字节数 - 1</td></tr> <tr><td>From IS</td> <td>w0,w1, wn：由字节对组成的 n+1 个字序列，高字节首先出现</td></tr> <tr><td>Pushes 压入栈</td> <td>w0,w1,...wn：n+1 个字的序列，每个字填充为 32 位 (uint32)</td></tr> <tr><td>相关指令</td> <td>NPUSHW[ ], PUSHB[ ]</td></tr></table> <p>从指令流中获取指定数量的字并将它们推送到解释器堆栈上。</p> <p>变量a、b和c是表示从000到111（0-7二进制）的数字的二进制数字。 值 1 会自动添加到 abc 数字中，以获得实际推送的字节数。</p> <p>当字值被压入堆栈时，它们被符号扩展为 32 位。</p> <h3 id="rcvt-read-control-value-table-entry-读取控制值表条目"><a href="#rcvt-read-control-value-table-entry-读取控制值表条目" class="header-anchor">#</a> RCVT[] Read Control Value Table entry--读取控制值表条目</h3> <table><tr><td>代码范围</td> <td>0x45</td></tr> <tr><td>Pops 弹出</td> <td>位置：CVT 条目号 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>值：CVT值（F26Dot6）</td></tr> <tr><td>相关说明</td> <td>WCVTP[ ], WCVTP[ ]</td></tr></table> <p>读取控制值表条目并将其值放入堆栈中。</p> <p>从堆栈中弹出 CVT 位置，并将在指定位置找到的值压入堆栈。</p> <h3 id="rdtg-round-down-to-grid-rdtg-向下舍入到网格"><a href="#rdtg-round-down-to-grid-rdtg-向下舍入到网格" class="header-anchor">#</a> RDTG[] Round Down To Grid--RDTG[] 向下舍入到网格</h3> <table><tr><td>代码范围</td> <td>0x7D</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>Sets</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RUTG[ ], RTG[], RTHG[], RTDG[], ROFF[]</td></tr></table> <p>将四舍五入状态变量设置为向下到网格。 在这种状态下，距离首先对引擎特性进行补偿，然后截断为整数。 如果补偿和舍入的结果是改变距离的符号，则距离设置为0。</p> <h3 id="roff-round-off-四舍五入关闭"><a href="#roff-round-off-四舍五入关闭" class="header-anchor">#</a> ROFF[] Round OFF--四舍五入关闭</h3> <table><tr><td>代码范围</td> <td>0x7A</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RDTG[], RUTG[ ], RTG[], RTHG[], RTDG[]</td></tr></table> <p>将舍入状态变量设置为舍入。 在这种状态下，会发生引擎补偿，但不会发生舍入。 如果引擎补偿会改变距离的符号，则该距离将设置为 0。</p> <h3 id="roll-roll-the-top-three-stack-elements-栈顶三个元素"><a href="#roll-roll-the-top-three-stack-elements-栈顶三个元素" class="header-anchor">#</a> ROLL[] ROLL the top three stack elements 栈顶三个元素</h3> <table><tr><td>代码范围</td> <td>0x8A</td></tr> <tr><td rowspan="3">Pops 弹出</td> <td>a：顶部堆栈元素</td></tr> <tr><td>b：从顶部开始的第二个堆栈元素</td></tr> <tr><td>c：从顶部开始的第三个堆栈元素</td></tr> <tr><td rowspan="3">Pushes 压入栈</td> <td>b：第二个堆栈元素</td></tr> <tr><td>a：顶部堆栈元素</td></tr> <tr><td>c：第三个堆栈元素</td></tr> <tr><td>相关说明</td> <td>MINDEX[ ]</td></tr></table> <p>对前三个堆栈元素执行循环平移。</p> <p>弹出前三个堆栈元素 a、b 和 c，并对堆栈上的前三个对象执行循环移动，其效果是将第三个元素移动到堆栈顶部，并将前两个元素向下移动一个位置。ROLL 等效于 MINDEX[]，值 3 位于堆栈顶部。</p> <h3 id="round-ab-round-value-四舍五入值"><a href="#round-ab-round-value-四舍五入值" class="header-anchor">#</a> ROUND[ab] ROUND value--四舍五入值</h3> <table><tr><td>代码范围</td> <td>0x68 - 0x6B</td></tr> <tr><td>表示Flags</td> <td>ab：用于引擎特性补偿的距离类型</td></tr> <tr><td>Pops 弹出</td> <td>n1：设备空间距离 （F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>n2：设备空间距离 （F26Dot6）</td></tr> <tr><td>相关说明</td> <td>NROUND[ ]</td></tr></table> <p>使用舍入状态，自由向量</p> <p>将堆栈顶部的值舍入，同时补偿引擎特性。</p> <p>弹出一个 26.6 的定点数 n1，并且根据布尔 ab 建立的发动机特性，结果按设定量增加或减少。然后根据当前舍入状态对获得的数字进行四舍五入，并作为 n2 推回堆栈。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入在零附近对称，包括对打印机网点大小的补偿。请参阅第 2-65 页的“使用颜色进行引擎补偿”。</p> <h3 id="rs-read-store-读取缓存"><a href="#rs-read-store-读取缓存" class="header-anchor">#</a> RS[] Read Store  读取缓存</h3> <table><tr><td>代码范围</td> <td>0x43</td></tr> <tr><td>Pops 弹出</td> <td>n：存储区位置（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>v：存储区域值（uint32）</td></tr> <tr><td>相关说明</td> <td>WS[ ]</td></tr></table> <p>读取指定存储区域位置中的值并将该值压入堆栈。</p> <p>从堆栈中弹出存储区域位置 n，并从该位置读取 32 位值 v。 读取的值被压入堆栈。 可用存储位置的数量在字体文件的“maxp”表中指定。</p> <h3 id="rtdg-round-to-double-grid-舍入为双网格"><a href="#rtdg-round-to-double-grid-舍入为双网格" class="header-anchor">#</a> RTDG[] Round To Double Grid 舍入为双网格</h3> <table><tr><td>代码范围</td> <td>0x3D</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RDTG[], ROFF[], RUTG[ ], RTG[], RTHG[]</td></tr></table> <p>将圆形状态变量设置为双网格。 在这种状态下，距离会根据引擎特性进行补偿，然后四舍五入为整数或半整数（以最接近的为准）。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入关于零对称，并且包括对打印机点大小的补偿。 请参阅第 2-65 页上的“使用颜色进行引擎补偿”。</p> <h3 id="rtg-舍入到网格"><a href="#rtg-舍入到网格" class="header-anchor">#</a> RTG[] 舍入到网格</h3> <table><tr><td>代码范围</td> <td>0x18</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RDTG[], ROFF[], RUTG[ ], RTDG[], RTHG[]</td></tr></table> <p>将舍入状态变量设置为网格。 在这种状态下，距离会根据引擎特性进行补偿，并四舍五入到最接近的整数。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入关于零对称，并且包括对打印机点大小的补偿。 请参阅第 2-65 页上的“使用颜色进行引擎补偿”。</p> <h3 id="rthg-round-to-half-grid-舍入到半网格"><a href="#rthg-round-to-half-grid-舍入到半网格" class="header-anchor">#</a> RTHG[] Round To Half Grid 舍入到半网格</h3> <table><tr><td>代码范围</td> <td>0x19</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RDTG[], ROFF[], RUTG[ ], RTDG[], RTG[]</td></tr></table> <p>将舍入状态变量设置为半网格。 在这种状态下，距离会根据引擎特性进行补偿，并四舍五入到最接近的半整数。 如果这些操作改变了距离的符号，则根据距离的原始符号将距离设置为+1/2或-1/2。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入关于零对称，并且包括对打印机点大小的补偿。 请参阅第 2-65 页上的“使用颜色进行引擎补偿”。</p> <h3 id="rutg-round-up-to-grid-向上舍入到网格"><a href="#rutg-round-up-to-grid-向上舍入到网格" class="header-anchor">#</a> RUTG[] Round Up To Grid 向上舍入到网格</h3> <table><tr><td>代码范围</td> <td>0x7C</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>RDTG[], ROFF[], RTDG[], RTG[], RTHG[]</td></tr></table> <p>将舍入状态变量向上舍入到网格。 在这种状态下，在补偿引擎特性之后，距离被四舍五入到最接近的整数。 如果补偿和舍入会改变距离的符号，则距离将设置为 0。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入关于零对称，并且包括对打印机点大小的补偿。 请参阅第 2-65 页上的“使用颜色进行引擎补偿”。</p> <h3 id="s45round-super-round-45-degrees-超级圆形45度"><a href="#s45round-super-round-45-degrees-超级圆形45度" class="header-anchor">#</a> S45ROUND[] Super ROUND 45 degrees 超级圆形45度</h3> <table><tr><td>代码范围</td> <td>0x77</td></tr> <tr><td>Pops 弹出</td> <td>n：uint32分解得到周期、相位、阈值（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>舍入状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>SROUND[ ]</td></tr></table> <p>S45ROUND[ ] 与 SROUND[ ] 类似。 不同之处在于它使用像素的 gridPeriod 而不是 1 个像素。 S45ROUND[ ] 可用于精细控制与 x 轴成 45 度角测量的距离的舍入。</p> <p><strong>警告</strong></p> <p>在 TrueType 中，舍入关于零对称，并且包括对打印机点大小的补偿。 请参阅第 2-65 页上的“使用颜色进行引擎补偿”。</p> <p>从堆栈中弹出一个数字 n 并分解该数字以获得周期、相位和用于设置图形状态变量回合状态值的阈值。 仅使用参数 n 的低 8 位来获取这些值。 该字节的编码如下表 2 所示。</p> <p><strong>表2</strong> SROUND[]字节编码</p> <table><tr><th colspan="2">周期</th> <th colspan="2">相位</th> <th colspan="3">阈值</th></tr> <tr><td>7</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td> <td>0</td></tr></table> <p>接下来的三个表给出了与 S45ROUND[] 指令中 n 的周期、相位和阈值分量的可能值相关的含义。</p> <p><strong>表 3：</strong> 设定周期</p> <p>位值设置
<table><tr><th>位值</th> <th>设定</th></tr> <tr><td>00</td> <td>sqr(2)/2 像素</td></tr> <tr><td>01</td> <td>sqr(2) 像素</td></tr> <tr><td>10</td> <td>2sqr(2) 像素</td></tr> <tr><td>11</td> <td>保留</td></tr></table></p> <p><strong>表 4：</strong> 设置相位</p> <table><tr><th>位值</th> <th>相位</th></tr> <tr><td>00</td> <td>0</td></tr> <tr><td>01</td> <td>周期/4</td></tr> <tr><td>10</td> <td>周期/2</td></tr> <tr><td>11</td> <td>周期 * 3/4</td></tr></table> <p><strong>表 5：</strong> 设置阈值</p> <table><tr><th>位值</th> <th>阈值</th></tr> <tr><td>0000</td> <td>周期-1</td></tr> <tr><td>0001</td> <td>-3/8 * 周期</td></tr> <tr><td>0010</td> <td>-2/8 * 周期</td></tr> <tr><td>0011</td> <td>-1/8 *  周期</td></tr> <tr><td>0100</td> <td>0/8 * 周期 = 0</td></tr> <tr><td>0101</td> <td>1/8 * 周期</td></tr> <tr><td>0110</td> <td>2/8 * 周期</td></tr> <tr><td>0111</td> <td>3/8 * 周期</td></tr> <tr><td>1000</td> <td>4/8 * 周期</td></tr> <tr><td>1001</td> <td>5/8 * 周期</td></tr> <tr><td>1010</td> <td>6/8 * 周期</td></tr> <tr><td>1011</td> <td>7/8 * 周期</td></tr> <tr><td>1100</td> <td>8/8 * 周期</td></tr> <tr><td>1101</td> <td>9/8 * 周期</td></tr> <tr><td>1110</td> <td>10/8 * 周期</td></tr> <tr><td>1111</td> <td>11/8 * 周期</td></tr></table> <h3 id="sangw-set-angle-weight-设置角度权重"><a href="#sangw-set-angle-weight-设置角度权重" class="header-anchor">#</a> SANGW[] Set ANGle Weight 设置角度权重</h3> <table><tr><td>代码范围</td> <td>0x7E</td></tr> <tr><td>Pops 弹出</td> <td>权重：角度权重值 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>角权重</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>指令AA[ ]</td></tr></table> <p>从堆栈中弹出一个 32 位整数权重，并相应地设置角度权重状态变量的值。 这个指示是不合时宜的。 除了弹出单个堆栈元素外，没有任何作用。</p> <h3 id="scanctrl-scan-conversion-control-scan-转换-control"><a href="#scanctrl-scan-conversion-control-scan-转换-control" class="header-anchor">#</a> SCANCTRL[] SCAN conversion ConTRoL SCAN 转换 ConTRoL</h3> <table><tr><td>代码范围</td> <td>0x85</td></tr> <tr><td>Pops 弹出</td> <td>n：指示何时打开 dropout 控制模式的标志</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>扫描控制</td></tr> <tr><td>相关说明</td> <td>SCANTYPE[ ]</td></tr></table> <p>弹出一个数字 n，该数字被分解为一组指定 dropout 控制模式的标志。 SCANCTRL 用于设置图形状态变量扫描控制的值，该值又确定扫描转换器是否将激活该字形的丢失控制。 使用压差控制模式由三个条件决定：</p> <p>字形是否旋转？
字形是否被拉伸？
ppem 的当前设置是否小于指定阈值？
解释器从堆栈中弹出一个字并查看低 13 位。</p> <p>位 0-7 表示 ppem 的阈值。 与位 8 一起，位 0-7 中的 FF 值意味着调用所有大小的丢失控制。 位 0-7 中的 Sia 值为 15 意味着调用低于每 em 16 像素的丢失控制。 请注意，0xFE 或 254 是可以有选择地调用丢失控制的每 em 的最大像素数。</p> <p>位 8-13 用于指定何时进行退出控制。 位 8、9 和 10 用于打开压差控制模式（假设其他条件不阻止它）。 位 11、12 和 13 用于关闭压差模式，除非其他条件强制这样做。</p> <table><tr><th>位</th> <th>设置的含义</th></tr> <tr><td>8</td> <td>如果其他条件不阻塞且 ppem 小于或等于阈值，则将 dropout 控制设置为 TRUE</td></tr> <tr><td>9</td> <td>如果其他条件不阻塞且字形旋转，则将 dropout 控制设置为 TRUE</td></tr> <tr><td>10</td> <td>如果其他条件不阻塞并且字形被拉伸，则将 dropout 控制设置为 TRUE。</td></tr> <tr><td>11</td> <td>将 dropout control 设置为 FALSE，除非 ppem 小于或等于阈值。</td></tr> <tr><td>12</td> <td>将 dropout 控制设置为 FALSE，除非字形旋转。</td></tr> <tr><td>13</td> <td>将 dropout 控制设置为 FALSE，除非字形被拉伸</td></tr></table> <p>例如，下面给出的值具有所述效果。</p> <table><tr><td>0x0</td> <td>不调用 dropout 控制</td></tr> <tr><td>0x1FF</td> <td>始终进行丢包控制</td></tr> <tr><td>0xA10</td> <td>如果字形旋转且每 em 少于 16 像素，则执行 dropout 控制</td></tr></table> <p>根据一组启用和禁用标志的值，扫描转换器可以在“正常”模式或“固定丢失”模式下操作。</p> <h3 id="scantype-扫描类型"><a href="#scantype-扫描类型" class="header-anchor">#</a> SCANTYPE[] 扫描类型</h3> <table><tr><td>代码范围</td> <td>0x8D</td></tr> <tr><td>Pops 弹出</td> <td>n：栈元素</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>扫描控制</td></tr> <tr><td>相关说明</td> <td>SCANCTRL[ ]</td></tr></table> <p>用于在带子和不带存根的 dropout 控制之间进行选择。</p> <p>弹出由扩展到 32 位的 16 位整数组成的堆栈元素。此整数的值用于确定扫描转换器将使用哪些规则。如果参数的值为 2，则将使用非压差控制扫描转换器。如果整数的值为 0 或 1，则将设置dropout控制模式。更具体地说，</p> <p>如果n=0，则调用规则1和2（丢弃控制扫描转换，包括存根）</p> <p>如果n=1，则调用规则1和3（丢弃控制扫描转换，不包括存根）</p> <p>如果 n=2 则调用规则 1（快速扫描转换）</p> <p>扫描转换规则如下所示：</p> <p>规则1
如果像素的中心落在字形轮廓内或之上，则该像素将打开并成为该字形的一部分。</p> <p>规则2
如果两个相邻像素中心（垂直或水平）之间的扫描线与 on-Transition 轮廓和 off-Transition 轮廓相交，并且这两个像素均未按照规则 1 打开，则打开最左侧的像素 （水平扫描线）或最底部像素（垂直扫描线）</p> <p>规则3
仅当两条轮廓继续与两个方向上的其他扫描线相交时才应用规则 2。 也就是说，不要打开“存根”的像素。 检查与相交的扫描线段形成正方形的扫描线段以验证它们是否被两个轮廓相交。 这些轮廓可能与与漏失扫描线段相交的轮廓不同。 这种情况不太可能发生，但可能必须通过某些奇异字形中的网格拟合来控制。</p> <h3 id="scfs-使用投影向量和自由向量从堆栈设置坐标"><a href="#scfs-使用投影向量和自由向量从堆栈设置坐标" class="header-anchor">#</a> SCFS[] 使用投影向量和自由向量从堆栈设置坐标</h3> <table><tr><td>代码范围</td> <td>0x48</td></tr> <tr><td rowspan="2">Pops 弹出</td> <td>c：坐标值（F26Dot6）</td></tr> <tr><td>p：点编号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp2、自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>GC[ ]</td></tr></table> <p>将点移动到堆栈上给定的坐标值指定的位置。</p> <p>弹出坐标值 c 和点编号 p，并将点 p 从其当前位置沿自由向量移动，以便其沿投影向量的分量成为从堆栈中弹出的值。</p> <p>该指令可用于在阴影区域“创建”点。</p> <p>在下图中，点 p 沿着自由向量移动，直到其在投影向量上的坐标值为 c。</p> <p><img src="data:image/gif;base64,R0lGODdhtgFZAYAAAP///wAAACwAAAAAtgFZAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV1tfY2drb2tGMD9reANDh4gPk5ufr5drs6d3p7NDr/+Pl8tb29dnz+Nz3+/758zfwKhESxoMCBCZgoXIsNXLqLDZBG9WWw48Zc8if8Zj100gLEjL3YfRRarCICjyWEVzR1cSSwkTI0yZ46saTNVywg4c9566RMY0KCoVE4YSpSUuJ4gk7JaigGpU09QNUidmsmoVaZYIXF98LVro7Bg35EVq/TAVbSrJGplK6vlWbig5NKNK3ftXaV55+7ttPPvT7+CPxEuvOkw4sSKF2dt7LgS5MiSKcfSa1nU5MyPMHM2/LmV59CaNpNmNPp0VtU6XaZm7WgpStiG7dIGbPs248C6S+fuPUll4NfA/1RNSZB48T3HQZpdHrtpgn3Kodd5i7xBdetwGmLczp2Ndwimw7epCd78oPLq76Rvb5w9fDvv55eRbz9O/fx48PP/d7Pff9cJ6BWBnflnYBoIJnjGggy64+CDVrw0m4R9pFOhhX7IFqF1HQ6RoYYXBMgEbyJaZUaFH5q3Ig7YncgBiUKECCMILcJAY40h3MhCjjqKIKOLQf7IAI8WoPcikQ16l6SSChY5pJNTmNWklGuQVKWVKxhJgY9a4jijl1++EGWMwo3p4g40commdDZ4yWabZUqQZZtpxiCmnWqSWaeeOsypVp9+iiHooFhQV6ihh7oGqKJGmOioE+AlGikRZKEUZ6U7HmlUppp+oFeen0IREqWjLqGQqKdKkZypqwZRqnONvgqmA5DSOiWiquLaBJW78tqrrK4Cm0RexG5h7LFa//Sl7KIZetosqL+5GW2v01bL6q3YkqrttpJe66213YYL4gLgkvsoAueWMGu0fa0IbaTJ4onujuO20C6ttsUZ75jz5tCvlP8KOSy2686gYr3kHSzDW/miOfANvwJbKsN4FvzqUBZfHLCG9UT8JsbEMjpxjyIry6yaJze7MY4PKwpyDSWTm6ynM4c7MJs349ytkSuj3LILO28bMw1DGxw0vj8fm7TSHf9YNMJLn+rr0SZYzfRF9zY8NcVbc/20jlGDHTaMKQPcNa7zZoq1u19zrPBRTW+Ztr5zq9A20G/z+TKRMt2Nd99Oagw4Cnmv+nHhJxyub6B7k+CauXEvrHiMzv+lNHlUlUsra+Z0bm4jtWWLaKzg6lokuufmQsrjRpgjZ7qWILdYFeqqhwN66E1BNTqDY9OtrlqvD6967h5Qt/vtjjN+/Op1y2s8kMoLf/rjZN++kfVbTl+W9ikwP3L0xz9vt/hmxu5nbvyir+fvQpOfsfnn9z5fzO6/T799rU7n/ffwt48o2IFvfthLVf8W9z+YnY5/Ksuf76rnErSxz1/VC57MEkg1BlKPYw40mwHhxr3PrY5vHRwclZxWQtnJD0oTDCGnUsi9AboQgS2c4edqaEOe4DCH3YOh8mTIQyBhMIhgoRwRJaadIR6RJ7jb4RKz58QlLk+KQIgiFcNxRVhrZbGKPpxhF7cIxjCKcYxkLKMZz4jGNKpxjWxsoxvfCMc4ynGOdKyjHe+IxzzqcY987KMf/wjIQApykIQspCEPichEKnKRjGykIx8JyUhKcpKUrKQlL4nJTGpyk5zspCc/CcpQinKUpPRTAQAAOw==" alt="F025_instr20"></p> <h3 id="scvtci-设置控制值表切入"><a href="#scvtci-设置控制值表切入" class="header-anchor">#</a> SCVTCI[] 设置控制值表切入</h3> <table><tr><td>代码范围</td> <td>0x1D</td></tr> <tr><td>Pops 弹出</td> <td>n：切入值（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>控制值切入</td></tr> <tr><td>相关说明</td> <td>MIAP, MIRP</td></tr></table> <p>为控制值表切入建立一个新值。</p> <p>从堆栈中弹出一个值 n，并将控制值切入设置为 n。 增加切入值将增加使用 CVT 值而不是原始轮廓值的尺寸范围。</p> <h3 id="sdb-设置图形状态下的delta-base"><a href="#sdb-设置图形状态下的delta-base" class="header-anchor">#</a> SDB[] 设置图形状态下的Delta Base</h3> <table><tr><td>代码范围</td> <td>0x5E</td></tr> <tr><td>Pops 弹出</td> <td>n： Delta 基数的值 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>delta 基础</td></tr> <tr><td>影响</td> <td>DELTAP1[], DELTAP2[], DELTAP3[], DELTAC1[], DELTAC2[], DELTAC3[]</td></tr> <tr><td>相关说明</td> <td>SDS[ ]</td></tr></table> <p>为 delta 基状态变量建立一个新值，从而更改 DELTA[] 指令影响的值范围。</p> <p>弹出一个数字 n，并将 delta 基数设置为值 n。 Delta 基数的默认值为 9。</p> <h3 id="sdpvtl-a-将双投影矢量设置为线"><a href="#sdpvtl-a-将双投影矢量设置为线" class="header-anchor">#</a> SDPVTL[a] 将双投影矢量设置为线</h3> <table><tr><td>代码范围</td> <td>0x86 - 0x87</td></tr> <tr><td>a</td> <td>0：矢量与直线平行</td></tr> <tr><td>1：向量垂直于线</td> <td></td></tr> <tr><td>Pops 弹出</td> <td>p2：点号（uint32）</td></tr> <tr><td>p1：点号（uint32）</td> <td></td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>双投影向量、投影向量、zp2 与 p2、zp1 与 p1</td></tr> <tr><td>相关说明</td> <td>SPVTL[ ]</td></tr></table> <p>根据两点的原始位置设置第二个投影向量。 新向量将指向与 p2 到 p1 定义的线平行的方向。 投影矢量也设置在与从 p2 到 p1 的线平行的方向上，但它是使用这些点的当前位置设置的。</p> <p>从堆栈中弹出两个点数，并使用它们来指定定义第二个双投影向量的线。 在执行任何指令之前，该双投影向量使用原始轮廓的坐标。 它仅与 IP[]、GC[]、MD[]、MDRP[] 和 MIRP[] 指令一起使用。 在这些指令中，使用双投影向量代替投影向量。 这将持续下去，直到某些指令再次设置投影向量。</p> <h3 id="sds-设置图形状态下的delta-shift"><a href="#sds-设置图形状态下的delta-shift" class="header-anchor">#</a> SDS[] 设置图形状态下的Delta Shift</h3> <table><tr><td>代码范围</td> <td>0x5F</td></tr> <tr><td>Pops 弹出</td> <td>n：增量偏移值 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>增量偏移</td></tr> <tr><td>影响</td> <td>DELTAP1[], DELTAP2[], DELTAP3[], DELTAC1[], DELTAC2[], DELTAC3[]</td></tr> <tr><td>相关说明</td> <td>SDB[ ]</td></tr></table> <p>为增量移位状态变量建立一个新值，从而更改 DELTA[] 指令的步长。</p> <p>从堆栈中弹出一个值 n 并将 delta shift 设置为 n。 增量偏移的默认值为 3。</p> <h3 id="sfvfs-从堆栈中设置自由向量"><a href="#sfvfs-从堆栈中设置自由向量" class="header-anchor">#</a> SFVFS[] 从堆栈中设置自由向量</h3> <table><tr><td>代码范围</td> <td>0x0B</td></tr> <tr><td>Pops 弹出</td> <td>y：自由向量的 y 分量 (F2Dot14)</td></tr> <tr><td>x：自由向量的 x 分量 (F2Dot14)</td> <td></td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自由向量</td></tr> <tr><td>相关说明</td> <td>SFVTL[ ], SFVTPV[ ], SFVTCA[ ]</td></tr></table> <p>使用从堆栈中获取的值更改自由向量的方向，从而更改点可以移动的方向。</p> <p>使用从堆栈中获取的值 x 和 y 设置自由向量的方向。 设置向量，使其在 x 和 y 轴上的投影为 x 和 y，它们被指定为有符号（二进制补码）定点 (2.14) 数。 值 (x2 + y2) 必须等于 1 (0x4000)。</p> <h3 id="sfvtca-a-将自由向量设置为坐标轴"><a href="#sfvtca-a-将自由向量设置为坐标轴" class="header-anchor">#</a> SFVTCA[a] 将自由向量设置为坐标轴</h3> <table><tr><td>代码范围</td> <td>0x04 - 0x05</td></tr> <tr><td rowspan="2">a</td> <td>0：将自由向量设置为y轴</td></tr> <tr><td>1：设置自由向量为x轴</td></tr> <tr><td>Pops 压入栈</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自由向量</td></tr> <tr><td>相关说明</td> <td>SFVFS[ ], SFVTL[ ], SFVTPV[ ]</td></tr></table> <p>根据标志 a 的值将自由向量设置为坐标轴之一。</p> <h3 id="sfvtl-a-将自由向量设置为线"><a href="#sfvtl-a-将自由向量设置为线" class="header-anchor">#</a> SFVTL[a] 将自由向量设置为线</h3> <table><tr><td>代码范围</td> <td>0x08 - 0x09</td></tr> <tr><td rowspan="2">a</td> <td>0：设置自由向量平行于点p1和p2定义的线段</td></tr> <tr><td>1：设置垂直于点p1和p2定义的线段的自由向量； 矢量逆时针旋转 90 度</td></tr> <tr><td rowspan="2">Pops 压入栈</td> <td>p2：点号（uint32）</td></tr> <tr><td>p1：点号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自由向量</td></tr> <tr><td>使用</td> <td>zp1 指向包含点 p1 的区域 zp2 指向包含点 p2 的区域</td></tr> <tr><td>相关说明</td> <td>SFVFS[ ], SFVTL[ ], SFVTPV[ ]</td></tr></table> <p>使用从堆栈中获取端点的线指定的方向更改自由向量的值。 效果是将点移动的方向更改为与该线平行。 选择点的顺序很重要。 颠倒顺序将颠倒自由向量的方向。</p> <p>从堆栈中弹出两个点号 p2 和 p1，并将自由向量设置为与点 p1 和 p2 定义并从 p2 指向 p1 的线段平行或垂直的单位向量。</p> <p>如果布尔值 a 的值为 0，则自由向量平行于从 p2 到 p1 的直线。</p> <p>如果布尔值 a 的值为 1，则自由向量垂直于从 p2 到 p1 的直线。 更准确地，通过逆时针旋转平行于线90的矢量来获得自由矢量。</p> <h3 id="sfvtpv-将自由向量设置为投影向量"><a href="#sfvtpv-将自由向量设置为投影向量" class="header-anchor">#</a> SFVTPV[] 将自由向量设置为投影向量</h3> <table><tr><td>代码范围</td> <td>0x0E</td></tr> <tr><td>Pops 弹出</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>自由向量</td></tr> <tr><td>相关说明</td> <td>SFVFS[ ], SFVTL[ ], SFVTCA[ ]</td></tr></table> <p>将自由向量设置为与投影向量相同。 这意味着移动和测量将沿同一方向。</p> <h3 id="shc-a-使用参考点移动轮廓"><a href="#shc-a-使用参考点移动轮廓" class="header-anchor">#</a> SHC[a] 使用参考点移动轮廓</h3> <table><tr><td>代码范围</td> <td>0x34 - 0x35</td></tr> <tr><td rowspan="2">a</td> <td>0：在zp1指向的区域中使用rp2</td></tr> <tr><td>1：在zp0指向的区域中使用rp1</td></tr> <tr><td>Pops 压入栈</td> <td>c：要移动的轮廓（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0 与 rp1 或 zp1 与 rp2 取决于标志 zp2 与轮廓 c 自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>SHP[ ], SHZ[ ]</td></tr></table> <p>将轮廓移动参考点移动的量。</p> <p>弹出数字 c，并将轮廓 c 上的每个点移动与参考点移动相同的量。 每个点沿着自由向量移动，使得该点的新位置和该点的旧位置之间的距离与参考点的当前位置和参考点的原始位置之间的距离相同。 距离是沿着投影矢量测量的。 如果参考点是定义轮廓的点之一，则该指令不会移动参考点。</p> <p>该指令与SHP[]类似，但轮廓上的每个点都会移位。</p> <p>在下图中，由 、 和 点形成的三角形轮廓移动了参考点 rp 从其原始位置移动的量 d。 新轮廓 p1、p2、p3 保留原始形状，但已在空间中沿自由向量平移量 d。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr21"></p> <h3 id="shp-a-使用参考点的移位点"><a href="#shp-a-使用参考点的移位点" class="header-anchor">#</a> SHP[a] 使用参考点的移位点</h3> <table><tr><td>代码范围</td> <td>0x32 - 0x33</td></tr> <tr><td rowspan="2">a</td> <td>0：在zp1指向的区域中使用rp2</td></tr> <tr><td>1：在zp0指向的区域中使用rp1</td></tr> <tr><td>Pops 压入栈</td> <td>p1, p2, , ploopvalue：要移动的点 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0 与 rp1 或 zp1 与 rp2 取决于标志 zp2 与点 p 循环、自由向量、投影向量</td></tr></table> <p>移动由参考点已移动量指定的点。</p> <p>弹出点编号 p1、p2、...、ploopvalue，并将这些点移动与参考点移动相同的量。 每个点pi沿着自由向量移动，使得点pi的新位置与点pi的当前位置之间的距离与参考点的当前位置与参考点的原始位置之间的距离相同。</p> <p>在下图中，参考点的当前位置与其原始位置之间的距离为 d。 直线 LL' 是在距点 A' 距离 d 处垂直于投影矢量绘制的。 点 p 沿着自由向量移动到向量与线 LL' 相交的点。 从点 A' 到 B' 的距离 d 现在与从 A 到 B 的距离相同。</p> <p><img src="data:image/gif;base64,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" alt="F025_instr22"></p> <h3 id="shpix-将点移位-pixel-量"><a href="#shpix-将点移位-pixel-量" class="header-anchor">#</a> SHPIX[] 将点移位 PIXel 量</h3> <table><tr><td>代码范围</td> <td>0x38</td></tr> <tr><td>Pops 压入栈</td> <td>d：偏移幅度 (F26Dot6)</td></tr> <tr><td>p1, p2, , ploopvalue: point to be shifted (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp2，循环，自由向量</td></tr> <tr><td>相关说明</td> <td>SHP[ ]</td></tr></table> <p>将指定点移动指定量。</p> <p>弹出点数 p1、p2、...、ploopvalue 和一个金额。 将每个点 pi 移动量 d。</p> <p>SHPIX[ ] 的独特之处在于仅依赖于自由向量的方向，它不使用投影向量。 测量是在自由矢量的方向上进行的。</p> <p>在下面的示例中，点 p 沿着自由向量移动 d 像素。</p> <p><img src="data:image/gif;base64,R0lGODdhjwEFAYAAAP///wAAACwAAAAAjwEFAQAC/4SPqcvtD6OctNqLs968+w+G4kiW5omm6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNarfcrvcLDovH5LL5jE6r1+y2+w2Py+f0uv2Oz+v3/L7/DxgoOEhYaHiImKi4yNjo+AgZKTlJWWl5iZmpucnZ6fkJGio6SlpqeoqaqrrK2ur6ChsrO0tba3uLm6u7y9vr+wscLDxMXGx8jJysvMzc7PwMHS09TV0dFxBgkG2tu43NDR4uPk6I/U1uuw2gji6rzr4O3476niA/X3nvYA5/jo/pL4I+ff/yEUQwsOCngBLMKVx4UEE2fg85TRTIzmFFTf8MF9zTuDFTQH4HQYYEGO9bR3srT046Z7JBTJeSVMabQJFmTW8t9/XUeYjiTIwRgQ4iqa2ox59GFzFdqrSpoYsVcjKIKhXP06v9kmZFtHVfyq+KwkpESJaRWW0HMqYFW9Vb27dlsd6cy/Ys3T9229bru9fO2nU3VXYNzFevxIt/7yL2w/DnyHeAH7+BGZZqZcvXSBb1x3gz5zWeP3u1KFpZabNyLVklt3oo1NSQZf9DimHwHtsndSelDec1Wd+8tRb/Wvl4Z99AmStn83yvc+ZghI/meiF6de3XT1OwPgZ894aELXCncn780tySgfMQr549+4RR4MfnQDyyexv274P/0A3SfjSk558GVH3XXw0lEVggfhlMRt0IHSXYIAoA2oMXfwhFWKGEUUWWoYIpCdihCKZhmJeCDJaoAoV+ceiBUCwKYReJBo404xCGDWWjeSvmqCJuQfYI5AulDfhjkTgcGUOSSuawmgsuPlmEZ96VMCWVR1gH42JdasnEfk6C6cSBPn5JJhSDZZnmF0yx2WZ48owZpxc7ElmnFnDmaUZOaPIZJgSy/QnoljIpR2ihNPZzXqKK/sBThHg++h6djlJ6w54YYfqEnyZcymkKwk26Yag6tkQqWqb6oKmHqy5Jp4mpvvpArJ/OSuuGoN6aK5a2StlrCK3usOujvy4Z7Jm4/6qYbK3HQlpesy8u20OxLD6bhLX3DXuFtqNxy4W3dIHrZrRpYruFuAoNhK6b1OID4bt2yovORO2moe4490JnrmVCQpJvNFbRy+9b5E5FcDH7AhIwMAc7YuZtCweVcC0PX9KwOxmrVbEqF4eyMSkfi+zMyNIiMfHJrKasMrEstwzlyzDD2vHMM5hs882CypyzqD7V3PMJH/Ec9AqgEV10C/8m3W3ITLNg5dNVvAa01LKuVLXVMUqmtQ5McuV01z6y5GXWYiO43ohnb0kQzmv77BeKb6Osaz1z0/2iqncbwajeexPRU9h/Zzf04Cj3bfjhSyfOeOOOPw555JJPTnnllk9fjnnmmm/Oeeeefw566KKPTnrppp+Oeuqqr856666/Dnvsss9Oe+2234577rrvznvvvv8OfPDCD0988cYfj3zyyi/PfPPOPw999NJPH0QBADs=" alt="F025_instr23"></p> <h3 id="shz-a-使用参考点的移动区域"><a href="#shz-a-使用参考点的移动区域" class="header-anchor">#</a> SHZ[a] 使用参考点的移动区域</h3> <table><tr><td>代码范围</td> <td>0x36 - 0x37</td></tr> <tr><td rowspan="2">a</td> <td>0：参考点rp2在zp1指向的区域内</td></tr> <tr><td>1：参考点rp1在zp0指向的区域内</td></tr> <tr><td>Pops 压入栈</td> <td>e：要移动的区域（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0 与 rp1 或 zp1 与 rp2 取决于标志自由向量、投影向量</td></tr> <tr><td>相关说明</td> <td>SHP[ ], SHC[ ]</td></tr></table> <p>将指定区域中的所有点移动参考点移动的量。</p> <p>弹出区域编号 e，并将指定区域（Z1 或 Z0）中的点移动与参考点移动量相同的量。 区域中的点将被移动，使得移动点的新位置与其旧位置之间的距离与参考点的当前位置与参考点的原始位置之间的距离相同。</p> <p>SHZ[a] 使用 zp0 和 rp1 或 zp1 和 rp2。 该指令与 SHC[ ] 类似，但区域中的所有点都会移位，而不仅仅是单个轮廓上的点。</p> <h3 id="sloop-设置loop变量"><a href="#sloop-设置loop变量" class="header-anchor">#</a> SLOOP[] 设置LOOP变量</h3> <table><tr><td>代码范围</td> <td>0x17</td></tr> <tr><td>Pops 压入栈</td> <td>n：循环图形状态变量的值（整数）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>循环</td></tr> <tr><td>影响</td> <td>ALIGNRP[], FLIPPT[], IP[], SHP[], SHPIX[]</td></tr> <tr><td>相关说明</td> <td>LOOPCALL[ ]</td></tr></table> <p>更改循环变量的值，从而更改受影响的指令在调用时执行的次数。</p> <p>从堆栈中弹出一个值 n，并将循环变量 count 设置为该值。 循环变量与 SHP[a]、SHPIX[a]、IP[ ] 和 ALIGNRP[] 一起使用。 值n表示指令要重复的次数。 指令执行所需次数后，循环变量将重置为其默认值 1。将循环变量设置为零是错误的。</p> <h3 id="smd-set-minimum-distance-设置最小距离"><a href="#smd-set-minimum-distance-设置最小距离" class="header-anchor">#</a> SMD[] Set Minimum Distance 设置最小距离</h3> <table><tr><td>代码范围</td> <td>0x1A</td></tr> <tr><td>Pops 压入栈</td> <td>distance：minimum_distance 的值 (F26Dot6)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>最小距离</td></tr></table> <p>为最小距离建立一个新值，即距离将舍入到的最小可能值。 该变量的适当设置可以防止距离四舍五入到零并因此在网格拟合发生时消失。</p> <p>从堆栈中弹出 26.6 值并将最小距离变量设置为该值。</p> <h3 id="spvfs-set-projection-vector-from-stack-设置堆栈中的投影向量"><a href="#spvfs-set-projection-vector-from-stack-设置堆栈中的投影向量" class="header-anchor">#</a> SPVFS[] Set Projection Vector From Stack 设置堆栈中的投影向量</h3> <table><tr><td>代码范围</td> <td>0x0A</td></tr> <tr><td>Pops 压入栈</td> <td>y：投影矢量 (F2Dot14) 的 y 分量 x：投影矢量 (F2Dot14) 的 x 分量</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>投影向量</td></tr> <tr><td>相关说明</td> <td>SPVTL[ ], SPVTCA[ ]</td></tr></table> <p>使用从堆栈中获取的值建立投影向量的新值。</p> <p>弹出两个数字 y 和 x，表示投影向量的 y 和 x 分量。 值 x 和 y 是扩展为 32 位的 2.14 数字。 使用从堆栈中获取的值 x 和 y 设置投影向量的方向，以便其在 x 轴和 y 轴上的投影为 x 和 y，它们被指定为有符号（二进制补码）定点 (2.14) 数字 。 值 (x2 + y2) 必须等于 1 (0x4000)。</p> <h3 id="spvtca-a-set-projection-vector-to-coordinate-axis-将投影矢量设置为坐标轴"><a href="#spvtca-a-set-projection-vector-to-coordinate-axis-将投影矢量设置为坐标轴" class="header-anchor">#</a> SPVTCA[a] Set Projection Vector To Coordinate Axis 将投影矢量设置为坐标轴</h3> <table><tr><td>代码范围</td> <td>0x02-0x03</td></tr> <tr><td rowspan="2">a</td> <td>0：设置投影向量到y轴</td></tr> <tr><td>1：设置投影向量到x轴</td></tr> <tr><td>Pops 压入栈</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>投影向量</td></tr> <tr><td>相关说明</td> <td>SPVTL[ ], SPVFS[ ]</td></tr></table> <p>根据标志 a 的值将投影矢量设置为坐标轴之一。</p> <h3 id="spvtl-a-set-projection-vector-to-line-将投影矢量设置为线"><a href="#spvtl-a-set-projection-vector-to-line-将投影矢量设置为线" class="header-anchor">#</a> SPVTL[a] Set Projection Vector To Line 将投影矢量设置为线</h3> <table><tr><td>代码范围</td> <td>0x06-0x07</td></tr> <tr><td rowspan="2">a</td> <td>0：设置投影向量平行于p2到p1的线段</td></tr> <tr><td>1：设置投影向量垂直于p2到p1的线段； 矢量逆时针旋转 90 度</td></tr> <tr><td rowspan="2">Pops 压入栈</td> <td>p2：点号（uint32）</td></tr> <tr><td>p1：点号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp1 指向的区域中的点 p1 zp2 指向的区域中的点 p2</td></tr> <tr><td>设置</td> <td>投影向量</td></tr> <tr><td>相关说明</td> <td>SPVFS[ ], SPVTCA[ ]</td></tr></table> <p>将投影矢量的方向更改为由从堆栈获取的端点定义的线指定的方向。 指定点的顺序很重要。颠倒点的顺序将颠倒投影矢量的方向。</p> <p>弹出两个点编号 p2 和 p1，并将投影向量设置为与从点 p2 到点 p1 并指向 p2 到 p1 的线段平行或垂直的单位向量。</p> <h3 id="sround-super-round-超级圆形"><a href="#sround-super-round-超级圆形" class="header-anchor">#</a> SROUND[] Super ROUND 超级圆形</h3> <table><tr><td>代码范围</td> <td>0x76</td></tr> <tr><td>Pops 压入栈</td> <td>n：分解得到周期、相位、阈值的数字（Eint8）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>圆形状态</td></tr> <tr><td>影响</td> <td>MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td></tr> <tr><td>相关说明</td> <td>S45ROUND[ ]</td></tr></table> <p>通过直接设置回合状态的三个组成部分的值：周期、相位和阈值，提供对回合状态变量的影响的精细控制。</p> <p>从堆栈中弹出一个数字 n 并分解该数字以获得周期、相位和用于设置图形状态变量回合状态值的阈值。 仅使用参数 n 的低 8 位来获取这些值。 该字节的编码如下表 8 所示。</p> <p><strong>表 8：</strong> SROUND 字节编码</p> <table><tr><th colspan="2">周期</th> <th colspan="2">相位</th> <th colspan="3">阈值</th></tr> <tr><td>7</td> <td>6</td> <td>5</td> <td>4</td> <td>3</td> <td>2</td> <td>1</td></tr></table> <p>&quot;句点&quot;指定舍入值之间的分隔或空格的长度。 相位指定舍入值与周期倍数的偏移量。 阈值指定在潜在舍入值之前映射到该值的域部分。有关舍入的其他信息可以在第 2-66 页的“舍入”中找到。</p> <p>对于 SROUND[]，用于计算表 9 中所示周期的网格周期等于 1.0 像素。 表 10 列出了相位的可能值，表 11 列出了阈值的可能值。</p> <p><strong>表 9：</strong> 设置周期
<table><tr><th>位值</th> <th>设置</th></tr> <tr><td>00</td> <td>1/2像素</td></tr> <tr><td>01</td> <td>1 像素</td></tr> <tr><td>10</td> <td>2 像素</td></tr> <tr><td>11</td> <td>预留的</td></tr></table></p> <p><strong>表 10：</strong> 设置相位
<table><tr><th>位值</th> <th>设置</th></tr> <tr><td>00</td> <td>周期/4</td></tr> <tr><td>01</td> <td>周期/2</td></tr> <tr><td>10</td> <td>周期 * 3/4</td></tr> <tr><td>11</td> <td>预留的</td></tr></table></p> <p><strong>表 11：</strong> 设置阈值</p> <table><tr><th>位值</th> <th>阈值</th></tr> <tr><td>0000</td> <td>周期-1</td></tr> <tr><td>0001</td> <td>-3/8 * 周期</td></tr> <tr><td>0010</td> <td>-2/8 * 周期</td></tr> <tr><td>0011</td> <td>-1/8 *  周期</td></tr> <tr><td>0100</td> <td>0/8 * 周期 = 0</td></tr> <tr><td>0101</td> <td>1/8 * 周期</td></tr> <tr><td>0110</td> <td>2/8 * 周期</td></tr> <tr><td>0111</td> <td>3/8 * 周期</td></tr> <tr><td>1000</td> <td>4/8 * 周期</td></tr> <tr><td>1001</td> <td>5/8 * 周期</td></tr> <tr><td>1010</td> <td>6/8 * 周期</td></tr> <tr><td>1011</td> <td>7/8 * 周期</td></tr> <tr><td>1100</td> <td>8/8 * 周期 = 周期</td></tr> <tr><td>1101</td> <td>9/8 * 周期</td></tr> <tr><td>1110</td> <td>10/8 * 周期</td></tr> <tr><td>1111</td> <td>11/8 * 周期</td></tr></table> <h3 id="srp0-set-reference-point-0-设置参考点0"><a href="#srp0-set-reference-point-0-设置参考点0" class="header-anchor">#</a> SRP0[] Set Reference Point 0 设置参考点0</h3> <table><tr><td>代码范围</td> <td>0x10</td></tr> <tr><td>Pops 压入栈</td> <td>p：点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>rp0</td></tr> <tr><td>影响</td> <td>ALIGNRP[], MDAP[], MDRP[], MIAP[], MIRP[] MSIRP[]</td></tr> <tr><td>相关说明</td> <td>SRP1[ ], SRP2[ ]</td></tr></table>
为参考点 0 设置新值。
<p>从堆栈中弹出一个点编号 p，并将 rp0 设置为 p。</p> <h3 id="srp1-set-reference-point-1-设置参考点-1"><a href="#srp1-set-reference-point-1-设置参考点-1" class="header-anchor">#</a> SRP1[] Set Reference Point 1 设置参考点 1</h3> <table><tr><td>代码范围</td> <td>0x11</td></tr> <tr><td>Pops 压入栈</td> <td>p：点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>rp1</td></tr> <tr><td>影响</td> <td>IP[], MDAP[], MIAP[], MSIRP[], SHC[], SHP[], SHZ</td></tr> <tr><td>相关说明</td> <td>SRP0[], SRP2[ ]</td></tr></table> <p>为参考点 1 设置新值。</p> <p>从堆栈中弹出一个点编号 p，并将 rp1 设置为 p。</p> <h3 id="srp2-set-reference-point-2-设置参考点-2"><a href="#srp2-set-reference-point-2-设置参考点-2" class="header-anchor">#</a> SRP2[] Set Reference Point 2 设置参考点 2</h3> <table><tr><td>代码范围</td> <td>0x12</td></tr> <tr><td>Pops 压入栈</td> <td>p：点数（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>rp2</td></tr> <tr><td>影响</td> <td>IP[], SHC[], SHP[], SHZ[]</td></tr> <tr><td>相关说明</td> <td>SRP1[ ], SRP0[]</td></tr></table> <p>为参考点 2 设置新值。</p> <p>从堆栈中弹出一个点编号 p，并将 rp2 设置为 p。</p> <h3 id="ssw-set-single-width-设置单宽度"><a href="#ssw-set-single-width-设置单宽度" class="header-anchor">#</a> SSW[] Set Single Width 设置单宽度</h3> <table><tr><td>代码范围</td> <td>0x1F</td></tr> <tr><td>Pops 压入栈</td> <td>n：单一宽度值（FUnit）的值</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>单一宽度值</td></tr> <tr><td>相关说明</td> <td>SSWCI[ ]</td></tr></table> <p>为单宽度值状态变量建立一个新值。 当单一宽度值与给定CVT条目之间的差小于单一宽度切入时，使用单一宽度值代替控制值表条目。</p> <p>从堆栈中弹出一个 32 位整数值 n，并将图形状态中的单个宽度值设置为 n。 n 值以 FUnit 表示。</p> <h3 id="sswci-set-single-width-cut-in-设置单宽度切点"><a href="#sswci-set-single-width-cut-in-设置单宽度切点" class="header-anchor">#</a> SSWCI[] Set Single Width Cut-In 设置单宽度切点</h3> <table><tr><td>代码范围</td> <td>0x1E</td></tr> <tr><td>Pops 压入栈</td> <td>n：单宽度切入值（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>单宽度切入</td></tr> <tr><td>影响</td> <td>MIAP[], MIRP[]</td></tr> <tr><td>相关说明</td> <td>SSW[ ]</td></tr></table> <p>为单宽度切入建立一个新值，解释器将忽略控制值表中的值以支持单宽度值的距离差。</p> <p>弹出 32 位整数值 n，并将单宽度切入设置为 n。</p> <h3 id="sub-减法"><a href="#sub-减法" class="header-anchor">#</a> SUB[] 减法</h3> <table><tr><td>代码范围</td> <td>0x61</td></tr> <tr><td rowspan="2">Pops 压入栈</td> <td>n2：减数（F26Dot6）</td></tr> <tr><td>n1：被减数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>(n1 - n2)：差异 (F26Dot6)</td></tr> <tr><td>相关说明</td> <td>ADD[ ]</td></tr></table> <p>用栈顶的数字减去栈顶的数字。</p> <p>从堆栈中弹出两个 26.6 数字 n1 和 n2，并将两个元素之间的差值压入堆栈。</p> <h3 id="svtca-a-set-freedom-and-projection-vectors-to-coordinate-axis-将自由度和投影向量设置为坐标轴"><a href="#svtca-a-set-freedom-and-projection-vectors-to-coordinate-axis-将自由度和投影向量设置为坐标轴" class="header-anchor">#</a> SVTCA[a] Set freedom and projection Vectors To Coordinate Axis 将自由度和投影向量设置为坐标轴</h3> <table><tr><td>代码范围</td> <td>0x00-0x01</td></tr> <tr><td rowspan="2">a</td> <td>0：将向量设置为 y 轴</td></tr> <tr><td>1：设置向量为x轴</td></tr> <tr><td>Pops 压入栈</td> <td>-</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td rowspan="2">设置</td> <td>投影向量</td></tr> <tr><td>自由向量</td></tr> <tr><td>相关说明</td> <td>SPTCA[ ], SFVTCA[ ]</td></tr></table> <p>将投影矢量和自由矢量设置为同一坐标轴，使移动和测量处于同一方向。 布尔变量a的设置决定轴的选择。</p> <p>SVTCA[ ] 是替代 SFVTCA[ ] 和 SPVTCA[ ] 指令的快捷方式。 因此，SVTCA[1] 相当于 SFVTCA[1] 后跟 SPVTCA[1]。</p> <h3 id="swap-swap-the-top-two-elements-on-the-stack-交换栈顶两个元素"><a href="#swap-swap-the-top-two-elements-on-the-stack-交换栈顶两个元素" class="header-anchor">#</a> SWAP[] SWAP the top two elements on the stack 交换栈顶两个元素</h3> <table><tr><td>代码范围</td> <td>0x23</td></tr> <tr><td rowspan="2">Pops 压入栈</td> <td>e2：堆栈元素（StkElt）</td></tr> <tr><td>e1：堆栈元素（StkElt）</td></tr> <tr><td rowspan="2">Pushes 压入栈</td> <td>e2：堆栈元素（StkElt）</td></tr> <tr><td>e1：堆栈元素（StkElt）</td></tr></table> <p>交换堆栈顶部的两个元素。</p> <p>从堆栈中弹出两个元素 e2 和 e1，并反转它们的顺序，使旧的顶部元素成为顶部元素，旧的第二个元素成为顶部元素。</p> <h3 id="szp0-set-zone-pointer-0-设置区域指针-0"><a href="#szp0-set-zone-pointer-0-设置区域指针-0" class="header-anchor">#</a> SZP0[] Set Zone Pointer 0 设置区域指针 0</h3> <table><tr><td>代码范围</td> <td>0x13</td></tr> <tr><td>Pops 弹出入栈</td> <td>n2：减数（F26Dot6）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>zp0</td></tr> <tr><td>影响</td> <td>AA[], ALIGNPTS[], ALIGNRP[], DELTAC1[], DELTAC2[], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[], FLIPPT[], FLIPRGOFF[], FLIPRGON[], IP[], ISECT[], MD[], MDAP[], MDRP[], MIAP[], MIRP[], MSIRP[], SHC[], SHE[], SHP[], SHZ[], UTP[]</td></tr> <tr><td>相关说明</td> <td>SZP1[ ], SZP2[ ], SZPS[ ]</td></tr></table> <p>为 zp0 建立一个新值。 它可以指向字形区域或暗区域。</p> <p>从堆栈中弹出区域编号 n，并将 zp0 设置为具有该编号的区域。 如果 n 的值为零，则 zp0 指向区域 0（暗区域）。 如果 n 的值为 1，则 zp0 指向区域 1（字形区域）。 n 的任何其他值都是错误的。</p> <h3 id="szp1-set-zone-pointer-1-设置区域指针-1"><a href="#szp1-set-zone-pointer-1-设置区域指针-1" class="header-anchor">#</a> SZP1[] Set Zone Pointer 1 设置区域指针 1</h3> <table><tr><td>代码范围</td> <td>0x14</td></tr> <tr><td>Pops 弹出入栈</td> <td>n：区域号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>zp1</td></tr> <tr><td>影响</td> <td>ALIGNPTS[], ALIGNRP[], IP[], ISECT[], MD[], MDRP[], MIRP[], MSIRP[], SDPVTL[], SFVTL[], SHC[], SHP[], SHZ[], SPVTL[]</td></tr> <tr><td>相关说明</td> <td>SZP0[ ], SZP2[ ], SZPS[ ]</td></tr></table> <p>为 zp1 建立新值。 它可以指向字形区域或阴影区域。</p> <p>从堆栈中弹出区域编号 n，并将 zp1 设置为具有该编号的区域。 如果 n 的值为零，则 zp1 指向区域 0（阴影区域）。 如果 n 的值为 1，则 zp1 指向区域 1（字形区域）。 n 的任何其他值都是错误的。</p> <h3 id="szp2-设置区域指针-2"><a href="#szp2-设置区域指针-2" class="header-anchor">#</a> SZP2[] 设置区域指针 2</h3> <table><tr><td>代码范围</td> <td>0x15</td></tr> <tr><td>Pops 弹出入栈</td> <td>n：区域号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>zp2</td></tr> <tr><td>影响</td> <td>IP[], ISECT[], IUP[], GC[], SDPVTL[], SHC[], SHP[], SFVTL[], SHPIX[], SPVTL[], SC[]</td></tr> <tr><td>相关说明</td> <td>SZP0[ ], SZP1[ ], SZPS[ ]</td></tr></table> <p>为 zp2 建立新值。 它可以指向字形区域或阴影区域。</p> <p>从堆栈中弹出区域编号 n，并将 zp2 设置为具有该编号的区域。 如果 n 的值为零，则 zp2 指向区域 0（阴影区域）。 如果 n 的值为 1，则 zp2 指向区域 1（字形区域）。 n 的任何其他值都是错误的。</p> <h3 id="szps-set-zone-pointers-设置区域指针s"><a href="#szps-set-zone-pointers-设置区域指针s" class="header-anchor">#</a> SZPS[] Set Zone PointerS 设置区域指针S</h3> <table><tr><td>代码范围</td> <td>0x16</td></tr> <tr><td>Pops 弹出</td> <td>n：区域号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>zp0, zp1, zp2</td></tr> <tr><td>影响</td> <td>ALIGNPTS[], ALIGNRP[], DELTAC1[], DELTAC2[], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[], FLIPPT[], FLIPRGOFF[], FLIPRGON[], GC[], IP[], ISECT[], IUP[], MD[], MDAP[], MDRP[], MIAP[], MIRP[], MSIRP[], SC[], SDPVTL[], SFVTL[], SHPIX[], SPVTL[], SHC[], SHP[], SHZ[], SPVTL[], UTP[]</td></tr> <tr><td>相关说明</td> <td>SZP0[ ], SZP1[ ], SZP2[ ]</td></tr></table> <p>设置所有三个区域指针以引用字形区域或阴影区域。</p> <p>从堆栈中弹出一个整数 n 并将所有区域指针设置为指向具有该数字的区域。 如果 n 为 0，则所有三个区域指针都将指向区域 0（阴影区域）。 如果 n 为 1，则所有三个区域指针都将指向区域 1（字形区域）。 n 的任何其他值都是错误的。</p> <h3 id="utp-untouch-point-非接触点"><a href="#utp-untouch-point-非接触点" class="header-anchor">#</a> UTP[] UnTouch Point 非接触点</h3> <table><tr><td>代码范围</td> <td>0x29</td></tr> <tr><td>Pops 弹出</td> <td>p：点编号（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>使用</td> <td>zp0 与点 p，自由向量</td></tr> <tr><td>影响</td> <td>IUP[ ]</td></tr></table> <p>将点标记为未触及，从而导致 IUP[ ] 指令影响其位置。</p> <p>弹出一个点编号 p，并将点 p 标记为未触及。 可以在x方向、y方向或者x和y方向上触摸点。 自由向量的位置决定该点是否在 x 方向、y 方向或同时在这两个方向上未被触及。 如果向量设置为 x 轴，则该点在 x 方向上将保持不变。 如果向量设置为 y 轴，则该点在 y 方向上将保持不变。 否则该点在两个方向上都不会被触及。</p> <p>标记为未触摸的点将被 IUP[ ] 指令移动，即使该点之前已被触摸过。</p> <h3 id="wcvtf-write-control-value-table-in-funits-在-funits-中写入控制值表"><a href="#wcvtf-write-control-value-table-in-funits-在-funits-中写入控制值表" class="header-anchor">#</a> WCVTF[] Write Control Value Table in Funits 在 Funits 中写入控制值表</h3> <table><tr><td>代码范围</td> <td>0x70</td></tr> <tr><td>Pops 弹出</td> <td>n：FUnit 中的数字 (uint32) l：控制值表位置 (uint32)</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>控制值表条目</td></tr> <tr><td>影响</td> <td>WCVTP[ ]</td></tr></table> <p>将缩放后的 F26Dot6 值写入指定的控制值表位置。</p> <p>从堆栈中弹出一个整数值 n 和一个控制值表位置 l。 FUnit 值缩放为当前点大小和分辨率，并放入控制值表中。 该指令假定该值以 FUnit 而非像素表示。</p> <p>由于 CVT 已缩放为像素值，因此从堆栈中取出的值在写入表之前会缩放为适当的像素值。</p> <h3 id="wcvtp-write-control-value-table-in-pixel-units-以像素为单位写入控制值表"><a href="#wcvtp-write-control-value-table-in-pixel-units-以像素为单位写入控制值表" class="header-anchor">#</a> WCVTP[] Write Control Value Table in Pixel units 以像素为单位写入控制值表</h3> <table><tr><td>代码范围</td> <td>0x44</td></tr> <tr><td>Pops 弹出</td> <td>v：以像素为单位的值 (F26Dot6)<br>
l：控制值表位置（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>控制值表条目</td></tr> <tr><td>影响</td> <td>WCVTF[ ]</td></tr></table> <p>将像素值写入指定的控制值表位置。</p> <p>从堆栈中弹出值 v 和控制值表位置 l 并将该值放入控制值表中的指定位置。 该指令假定从堆栈中获取的值以像素为单位，而不是以 FUnit 为单位。 该值不变地写入 CVT 表。 位置l必须小于字体文件中'maxp'表中指定的存储位置的数量。</p> <h3 id="ws-write-store-写存储"><a href="#ws-write-store-写存储" class="header-anchor">#</a> WS[] Write Store 写存储</h3> <table><tr><td>代码范围</td> <td>0x42</td></tr> <tr><td>Pops 弹出</td> <td>v：存储区域值（uint32）<br>
l：存储区位置（uint32）</td></tr> <tr><td>Pushes 压入栈</td> <td>-</td></tr> <tr><td>设置</td> <td>存储区值</td></tr> <tr><td>影响</td> <td>RS[ ]</td></tr></table> <p>将从堆栈中取出的值写入指定的存储区域位置。</p> <p>弹出存储区域位置 l，后跟一个值 v。将此 32 位值写入由 l 索引的存储区域位置。 该值必须小于字体文件的“maxp”表中指定的存储位置数。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Graphics_State.html" class="prev">
        图形状态
      </a></span> <span class="next"><a href="/Instruction_Set_Summary.html">
        指令集摘要
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ab2bc41e.js" defer></script><script src="/assets/js/2.f8441915.js" defer></script><script src="/assets/js/1.582e94f5.js" defer></script><script src="/assets/js/13.61a706c7.js" defer></script>
  </body>
</html>
