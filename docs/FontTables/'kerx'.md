# "kerx"表

## 一般表信息

字距调整（'kern'）表的格式最初设计于 1988 年。当时，680x0 处理器是设计中心，内存相对昂贵。 由于这些限制，表格式被设计为占用尽可能少的空间，并使用加速处理的“技巧”。

然而，在运行千兆赫处理器的多千兆字节机器的世界中，这种设计是不合时宜的，更糟糕的是，这是一种障碍。 开发人员希望创建的字体所需的字体超出了原始“kern”表所能提供的范围。 为此，引入了扩展的字距调整表，即“kerx”表。

“kerx”表包含调整字体中字形位置的值。 它可以有多个不同格式的子表，其中可以包含垂直或水平文本的信息。

调整可以平行于文本流或垂直于文本流，或两者兼而有之。 例如，如果指定垂直调整并且文本通常水平书写，则调整将向上或向下。

当前定义了四种定位格式，格式 0、1、2、4 和 6。文件格式规范允许定义其他格式以供进一步使用。 格式 3、5、7 到 255 保留供将来使用。

每个子表可以采用下面指定的四种格式之一，并且可以包含垂直或水平文本的信息。 字体可以有多个“kerx”子表，但由于这些表所做的调整是累加性的，因此包含调整的子表的顺序并不重要。

定位表有一个标题，其中包含格式编号、存在的子表数量以及子表本身。

'kerx' **表**
|类型|名称|描述|
|-|-|-|
|uint16|version|扩展字距调整表的版本号（当前为 2、3 或 4）。|
|uint16|填充未使用； |设置为零。|
|uint32|nTables|扩展字距调整表中包含的子表的数量。|

如果“kerx”表版本为 3 或更高，则最后一个子表后跟有 subtableGlyphCoverageArray，如下所述。

如果“kerx”表版本为 4 或更大，则字距调整值可以是单个值或向量，如下所述。

定位子表还有一个标头，用于标识子表的格式及其包含的信息类型。

'kerx' **子表头**

|类型|名称|描述|
|-|-|-|
|uint32|length| 此子表的长度（以字节为单位），包括此标头。|
|uint32|覆盖范围| 使用此表的情况。 请参阅下面的说明。|
|uint32|tupleCount| 元组计数。 该值仅与变体字体一起使用，对于所有其他字体应为 0。 如果“kerx”表版本小于 4，则子表的 tupleCount 将被忽略。|

如果子表的 tupleCount 大于零，则子表不包含单个紧排值，而是包含与字体的“gvar”表中的全局元组关联的紧排值的 tupleCount 维向量。 支持的方式根据子表格式的不同而不同。

子表覆盖字段分为以下给出的子字段。

覆盖领域

|掩码值|名称|说明|
|-|-|-|
|0x80000000|垂直| 设置表格是否具有垂直字距调整值。|
|0x40000000|crossStream| 设置表是否具有跨流字距调整值。|
|0x20000000|变化| 设置表是否具有变化字距调整值。|
|0x10000000|processDirection| 进程方向标志。 如果清除，则向前处理字形，即从字形流中的第一个到最后一个。 如果我们从最后到第一个处理它们。 该标志仅适用于基于状态表的“kerx”子表（类型 1 和 4）。|
|0x0FFFFF00|未使用位|设置为 0。|
|0x000000FF|formatMask| 这些字节包含该子表的格式（当前定义的0、1、2、4和6）。|